"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/c32check";
exports.ids = ["vendor-chunks/c32check"];
exports.modules = {

/***/ "(ssr)/./node_modules/c32check/lib/address.js":
/*!**********************************************!*\
  !*** ./node_modules/c32check/lib/address.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.c32ToB58 = exports.b58ToC32 = exports.c32addressDecode = exports.c32address = exports.versions = void 0;\nconst checksum_1 = __webpack_require__(/*! ./checksum */ \"(ssr)/./node_modules/c32check/lib/checksum.js\");\nconst base58check = __webpack_require__(/*! ./base58check */ \"(ssr)/./node_modules/c32check/lib/base58check.js\");\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/utils.js\");\nexports.versions = {\n    mainnet: {\n        p2pkh: 22,\n        p2sh: 20\n    },\n    testnet: {\n        p2pkh: 26,\n        p2sh: 21\n    }\n};\n// address conversion : bitcoin to stacks\nconst ADDR_BITCOIN_TO_STACKS = {};\nADDR_BITCOIN_TO_STACKS[0] = exports.versions.mainnet.p2pkh;\nADDR_BITCOIN_TO_STACKS[5] = exports.versions.mainnet.p2sh;\nADDR_BITCOIN_TO_STACKS[111] = exports.versions.testnet.p2pkh;\nADDR_BITCOIN_TO_STACKS[196] = exports.versions.testnet.p2sh;\n// address conversion : stacks to bitcoin\nconst ADDR_STACKS_TO_BITCOIN = {};\nADDR_STACKS_TO_BITCOIN[exports.versions.mainnet.p2pkh] = 0;\nADDR_STACKS_TO_BITCOIN[exports.versions.mainnet.p2sh] = 5;\nADDR_STACKS_TO_BITCOIN[exports.versions.testnet.p2pkh] = 111;\nADDR_STACKS_TO_BITCOIN[exports.versions.testnet.p2sh] = 196;\n/**\n * Make a c32check address with the given version and hash160\n * The only difference between a c32check string and c32 address\n * is that the letter 'S' is pre-pended.\n * @param {number} version - the address version number\n * @param {string} hash160hex - the hash160 to encode (must be a hash160)\n * @returns {string} the address\n */ function c32address(version, hash160hex) {\n    if (!hash160hex.match(/^[0-9a-fA-F]{40}$/)) {\n        throw new Error(\"Invalid argument: not a hash160 hex string\");\n    }\n    const c32string = (0, checksum_1.c32checkEncode)(version, hash160hex);\n    return `S${c32string}`;\n}\nexports.c32address = c32address;\n/**\n * Decode a c32 address into its version and hash160\n * @param {string} c32addr - the c32check-encoded address\n * @returns {[number, string]} a tuple with the version and hash160\n */ function c32addressDecode(c32addr) {\n    if (c32addr.length <= 5) {\n        throw new Error(\"Invalid c32 address: invalid length\");\n    }\n    if (c32addr[0] != \"S\") {\n        throw new Error('Invalid c32 address: must start with \"S\"');\n    }\n    return (0, checksum_1.c32checkDecode)(c32addr.slice(1));\n}\nexports.c32addressDecode = c32addressDecode;\n/*\n * Convert a base58check address to a c32check address.\n * Try to convert the version number if one is not given.\n * @param {string} b58check - the base58check encoded address\n * @param {number} version - the version number, if not inferred from the address\n * @returns {string} the c32 address with the given version number (or the\n *   semantically-equivalent c32 version number, if not given)\n */ function b58ToC32(b58check, version = -1) {\n    const addrInfo = base58check.decode(b58check);\n    const hash160String = (0, utils_1.bytesToHex)(addrInfo.data);\n    const addrVersion = parseInt((0, utils_1.bytesToHex)(addrInfo.prefix), 16);\n    let stacksVersion;\n    if (version < 0) {\n        stacksVersion = addrVersion;\n        if (ADDR_BITCOIN_TO_STACKS[addrVersion] !== undefined) {\n            stacksVersion = ADDR_BITCOIN_TO_STACKS[addrVersion];\n        }\n    } else {\n        stacksVersion = version;\n    }\n    return c32address(stacksVersion, hash160String);\n}\nexports.b58ToC32 = b58ToC32;\n/*\n * Convert a c32check address to a base58check address.\n * @param {string} c32string - the c32check address\n * @param {number} version - the version number, if not inferred from the address\n * @returns {string} the base58 address with the given version number (or the\n *    semantically-equivalent bitcoin version number, if not given)\n */ function c32ToB58(c32string, version = -1) {\n    const addrInfo = c32addressDecode(c32string);\n    const stacksVersion = addrInfo[0];\n    const hash160String = addrInfo[1];\n    let bitcoinVersion;\n    if (version < 0) {\n        bitcoinVersion = stacksVersion;\n        if (ADDR_STACKS_TO_BITCOIN[stacksVersion] !== undefined) {\n            bitcoinVersion = ADDR_STACKS_TO_BITCOIN[stacksVersion];\n        }\n    } else {\n        bitcoinVersion = version;\n    }\n    let prefix = bitcoinVersion.toString(16);\n    if (prefix.length === 1) {\n        prefix = `0${prefix}`;\n    }\n    return base58check.encode(hash160String, prefix);\n}\nexports.c32ToB58 = c32ToB58;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYzMyY2hlY2svbGliL2FkZHJlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGdCQUFnQixHQUFHQSxnQkFBZ0IsR0FBR0Esd0JBQXdCLEdBQUdBLGtCQUFrQixHQUFHQSxnQkFBZ0IsR0FBRyxLQUFLO0FBQzlHLE1BQU1PLGFBQWFDLG1CQUFPQSxDQUFDLGlFQUFZO0FBQ3ZDLE1BQU1DLGNBQWNELG1CQUFPQSxDQUFDLHVFQUFlO0FBQzNDLE1BQU1FLFVBQVVGLG1CQUFPQSxDQUFDLHdFQUFxQjtBQUM3Q1IsZ0JBQWdCLEdBQUc7SUFDZlcsU0FBUztRQUNMQyxPQUFPO1FBQ1BDLE1BQU07SUFDVjtJQUNBQyxTQUFTO1FBQ0xGLE9BQU87UUFDUEMsTUFBTTtJQUNWO0FBQ0o7QUFDQSx5Q0FBeUM7QUFDekMsTUFBTUUseUJBQXlCLENBQUM7QUFDaENBLHNCQUFzQixDQUFDLEVBQUUsR0FBR2YsUUFBUU0sUUFBUSxDQUFDSyxPQUFPLENBQUNDLEtBQUs7QUFDMURHLHNCQUFzQixDQUFDLEVBQUUsR0FBR2YsUUFBUU0sUUFBUSxDQUFDSyxPQUFPLENBQUNFLElBQUk7QUFDekRFLHNCQUFzQixDQUFDLElBQUksR0FBR2YsUUFBUU0sUUFBUSxDQUFDUSxPQUFPLENBQUNGLEtBQUs7QUFDNURHLHNCQUFzQixDQUFDLElBQUksR0FBR2YsUUFBUU0sUUFBUSxDQUFDUSxPQUFPLENBQUNELElBQUk7QUFDM0QseUNBQXlDO0FBQ3pDLE1BQU1HLHlCQUF5QixDQUFDO0FBQ2hDQSxzQkFBc0IsQ0FBQ2hCLFFBQVFNLFFBQVEsQ0FBQ0ssT0FBTyxDQUFDQyxLQUFLLENBQUMsR0FBRztBQUN6REksc0JBQXNCLENBQUNoQixRQUFRTSxRQUFRLENBQUNLLE9BQU8sQ0FBQ0UsSUFBSSxDQUFDLEdBQUc7QUFDeERHLHNCQUFzQixDQUFDaEIsUUFBUU0sUUFBUSxDQUFDUSxPQUFPLENBQUNGLEtBQUssQ0FBQyxHQUFHO0FBQ3pESSxzQkFBc0IsQ0FBQ2hCLFFBQVFNLFFBQVEsQ0FBQ1EsT0FBTyxDQUFDRCxJQUFJLENBQUMsR0FBRztBQUN4RDs7Ozs7OztDQU9DLEdBQ0QsU0FBU1IsV0FBV1ksT0FBTyxFQUFFQyxVQUFVO0lBQ25DLElBQUksQ0FBQ0EsV0FBV0MsS0FBSyxDQUFDLHNCQUFzQjtRQUN4QyxNQUFNLElBQUlDLE1BQU07SUFDcEI7SUFDQSxNQUFNQyxZQUFZLENBQUMsR0FBR2QsV0FBV2UsY0FBYyxFQUFFTCxTQUFTQztJQUMxRCxPQUFPLENBQUMsQ0FBQyxFQUFFRyxVQUFVLENBQUM7QUFDMUI7QUFDQXJCLGtCQUFrQixHQUFHSztBQUNyQjs7OztDQUlDLEdBQ0QsU0FBU0QsaUJBQWlCbUIsT0FBTztJQUM3QixJQUFJQSxRQUFRQyxNQUFNLElBQUksR0FBRztRQUNyQixNQUFNLElBQUlKLE1BQU07SUFDcEI7SUFDQSxJQUFJRyxPQUFPLENBQUMsRUFBRSxJQUFJLEtBQUs7UUFDbkIsTUFBTSxJQUFJSCxNQUFNO0lBQ3BCO0lBQ0EsT0FBTyxDQUFDLEdBQUdiLFdBQVdrQixjQUFjLEVBQUVGLFFBQVFHLEtBQUssQ0FBQztBQUN4RDtBQUNBMUIsd0JBQXdCLEdBQUdJO0FBQzNCOzs7Ozs7O0NBT0MsR0FDRCxTQUFTRCxTQUFTd0IsUUFBUSxFQUFFVixVQUFVLENBQUMsQ0FBQztJQUNwQyxNQUFNVyxXQUFXbkIsWUFBWW9CLE1BQU0sQ0FBQ0Y7SUFDcEMsTUFBTUcsZ0JBQWdCLENBQUMsR0FBR3BCLFFBQVFxQixVQUFVLEVBQUVILFNBQVNJLElBQUk7SUFDM0QsTUFBTUMsY0FBY0MsU0FBUyxDQUFDLEdBQUd4QixRQUFRcUIsVUFBVSxFQUFFSCxTQUFTTyxNQUFNLEdBQUc7SUFDdkUsSUFBSUM7SUFDSixJQUFJbkIsVUFBVSxHQUFHO1FBQ2JtQixnQkFBZ0JIO1FBQ2hCLElBQUlsQixzQkFBc0IsQ0FBQ2tCLFlBQVksS0FBS0ksV0FBVztZQUNuREQsZ0JBQWdCckIsc0JBQXNCLENBQUNrQixZQUFZO1FBQ3ZEO0lBQ0osT0FDSztRQUNERyxnQkFBZ0JuQjtJQUNwQjtJQUNBLE9BQU9aLFdBQVcrQixlQUFlTjtBQUNyQztBQUNBOUIsZ0JBQWdCLEdBQUdHO0FBQ25COzs7Ozs7Q0FNQyxHQUNELFNBQVNELFNBQVNtQixTQUFTLEVBQUVKLFVBQVUsQ0FBQyxDQUFDO0lBQ3JDLE1BQU1XLFdBQVd4QixpQkFBaUJpQjtJQUNsQyxNQUFNZSxnQkFBZ0JSLFFBQVEsQ0FBQyxFQUFFO0lBQ2pDLE1BQU1FLGdCQUFnQkYsUUFBUSxDQUFDLEVBQUU7SUFDakMsSUFBSVU7SUFDSixJQUFJckIsVUFBVSxHQUFHO1FBQ2JxQixpQkFBaUJGO1FBQ2pCLElBQUlwQixzQkFBc0IsQ0FBQ29CLGNBQWMsS0FBS0MsV0FBVztZQUNyREMsaUJBQWlCdEIsc0JBQXNCLENBQUNvQixjQUFjO1FBQzFEO0lBQ0osT0FDSztRQUNERSxpQkFBaUJyQjtJQUNyQjtJQUNBLElBQUlrQixTQUFTRyxlQUFlQyxRQUFRLENBQUM7SUFDckMsSUFBSUosT0FBT1gsTUFBTSxLQUFLLEdBQUc7UUFDckJXLFNBQVMsQ0FBQyxDQUFDLEVBQUVBLE9BQU8sQ0FBQztJQUN6QjtJQUNBLE9BQU8xQixZQUFZK0IsTUFBTSxDQUFDVixlQUFlSztBQUM3QztBQUNBbkMsZ0JBQWdCLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmVyaWZpZWQtZGV4LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2MzMmNoZWNrL2xpYi9hZGRyZXNzLmpzP2ZlM2YiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmMzMlRvQjU4ID0gZXhwb3J0cy5iNThUb0MzMiA9IGV4cG9ydHMuYzMyYWRkcmVzc0RlY29kZSA9IGV4cG9ydHMuYzMyYWRkcmVzcyA9IGV4cG9ydHMudmVyc2lvbnMgPSB2b2lkIDA7XG5jb25zdCBjaGVja3N1bV8xID0gcmVxdWlyZShcIi4vY2hlY2tzdW1cIik7XG5jb25zdCBiYXNlNThjaGVjayA9IHJlcXVpcmUoXCIuL2Jhc2U1OGNoZWNrXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCIpO1xuZXhwb3J0cy52ZXJzaW9ucyA9IHtcbiAgICBtYWlubmV0OiB7XG4gICAgICAgIHAycGtoOiAyMixcbiAgICAgICAgcDJzaDogMjAsIC8vICdNJ1xuICAgIH0sXG4gICAgdGVzdG5ldDoge1xuICAgICAgICBwMnBraDogMjYsXG4gICAgICAgIHAyc2g6IDIxLCAvLyAnTidcbiAgICB9LFxufTtcbi8vIGFkZHJlc3MgY29udmVyc2lvbiA6IGJpdGNvaW4gdG8gc3RhY2tzXG5jb25zdCBBRERSX0JJVENPSU5fVE9fU1RBQ0tTID0ge307XG5BRERSX0JJVENPSU5fVE9fU1RBQ0tTWzBdID0gZXhwb3J0cy52ZXJzaW9ucy5tYWlubmV0LnAycGtoO1xuQUREUl9CSVRDT0lOX1RPX1NUQUNLU1s1XSA9IGV4cG9ydHMudmVyc2lvbnMubWFpbm5ldC5wMnNoO1xuQUREUl9CSVRDT0lOX1RPX1NUQUNLU1sxMTFdID0gZXhwb3J0cy52ZXJzaW9ucy50ZXN0bmV0LnAycGtoO1xuQUREUl9CSVRDT0lOX1RPX1NUQUNLU1sxOTZdID0gZXhwb3J0cy52ZXJzaW9ucy50ZXN0bmV0LnAyc2g7XG4vLyBhZGRyZXNzIGNvbnZlcnNpb24gOiBzdGFja3MgdG8gYml0Y29pblxuY29uc3QgQUREUl9TVEFDS1NfVE9fQklUQ09JTiA9IHt9O1xuQUREUl9TVEFDS1NfVE9fQklUQ09JTltleHBvcnRzLnZlcnNpb25zLm1haW5uZXQucDJwa2hdID0gMDtcbkFERFJfU1RBQ0tTX1RPX0JJVENPSU5bZXhwb3J0cy52ZXJzaW9ucy5tYWlubmV0LnAyc2hdID0gNTtcbkFERFJfU1RBQ0tTX1RPX0JJVENPSU5bZXhwb3J0cy52ZXJzaW9ucy50ZXN0bmV0LnAycGtoXSA9IDExMTtcbkFERFJfU1RBQ0tTX1RPX0JJVENPSU5bZXhwb3J0cy52ZXJzaW9ucy50ZXN0bmV0LnAyc2hdID0gMTk2O1xuLyoqXG4gKiBNYWtlIGEgYzMyY2hlY2sgYWRkcmVzcyB3aXRoIHRoZSBnaXZlbiB2ZXJzaW9uIGFuZCBoYXNoMTYwXG4gKiBUaGUgb25seSBkaWZmZXJlbmNlIGJldHdlZW4gYSBjMzJjaGVjayBzdHJpbmcgYW5kIGMzMiBhZGRyZXNzXG4gKiBpcyB0aGF0IHRoZSBsZXR0ZXIgJ1MnIGlzIHByZS1wZW5kZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gdmVyc2lvbiAtIHRoZSBhZGRyZXNzIHZlcnNpb24gbnVtYmVyXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFzaDE2MGhleCAtIHRoZSBoYXNoMTYwIHRvIGVuY29kZSAobXVzdCBiZSBhIGhhc2gxNjApXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgYWRkcmVzc1xuICovXG5mdW5jdGlvbiBjMzJhZGRyZXNzKHZlcnNpb24sIGhhc2gxNjBoZXgpIHtcbiAgICBpZiAoIWhhc2gxNjBoZXgubWF0Y2goL15bMC05YS1mQS1GXXs0MH0kLykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50OiBub3QgYSBoYXNoMTYwIGhleCBzdHJpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgYzMyc3RyaW5nID0gKDAsIGNoZWNrc3VtXzEuYzMyY2hlY2tFbmNvZGUpKHZlcnNpb24sIGhhc2gxNjBoZXgpO1xuICAgIHJldHVybiBgUyR7YzMyc3RyaW5nfWA7XG59XG5leHBvcnRzLmMzMmFkZHJlc3MgPSBjMzJhZGRyZXNzO1xuLyoqXG4gKiBEZWNvZGUgYSBjMzIgYWRkcmVzcyBpbnRvIGl0cyB2ZXJzaW9uIGFuZCBoYXNoMTYwXG4gKiBAcGFyYW0ge3N0cmluZ30gYzMyYWRkciAtIHRoZSBjMzJjaGVjay1lbmNvZGVkIGFkZHJlc3NcbiAqIEByZXR1cm5zIHtbbnVtYmVyLCBzdHJpbmddfSBhIHR1cGxlIHdpdGggdGhlIHZlcnNpb24gYW5kIGhhc2gxNjBcbiAqL1xuZnVuY3Rpb24gYzMyYWRkcmVzc0RlY29kZShjMzJhZGRyKSB7XG4gICAgaWYgKGMzMmFkZHIubGVuZ3RoIDw9IDUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGMzMiBhZGRyZXNzOiBpbnZhbGlkIGxlbmd0aCcpO1xuICAgIH1cbiAgICBpZiAoYzMyYWRkclswXSAhPSAnUycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGMzMiBhZGRyZXNzOiBtdXN0IHN0YXJ0IHdpdGggXCJTXCInKTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBjaGVja3N1bV8xLmMzMmNoZWNrRGVjb2RlKShjMzJhZGRyLnNsaWNlKDEpKTtcbn1cbmV4cG9ydHMuYzMyYWRkcmVzc0RlY29kZSA9IGMzMmFkZHJlc3NEZWNvZGU7XG4vKlxuICogQ29udmVydCBhIGJhc2U1OGNoZWNrIGFkZHJlc3MgdG8gYSBjMzJjaGVjayBhZGRyZXNzLlxuICogVHJ5IHRvIGNvbnZlcnQgdGhlIHZlcnNpb24gbnVtYmVyIGlmIG9uZSBpcyBub3QgZ2l2ZW4uXG4gKiBAcGFyYW0ge3N0cmluZ30gYjU4Y2hlY2sgLSB0aGUgYmFzZTU4Y2hlY2sgZW5jb2RlZCBhZGRyZXNzXG4gKiBAcGFyYW0ge251bWJlcn0gdmVyc2lvbiAtIHRoZSB2ZXJzaW9uIG51bWJlciwgaWYgbm90IGluZmVycmVkIGZyb20gdGhlIGFkZHJlc3NcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBjMzIgYWRkcmVzcyB3aXRoIHRoZSBnaXZlbiB2ZXJzaW9uIG51bWJlciAob3IgdGhlXG4gKiAgIHNlbWFudGljYWxseS1lcXVpdmFsZW50IGMzMiB2ZXJzaW9uIG51bWJlciwgaWYgbm90IGdpdmVuKVxuICovXG5mdW5jdGlvbiBiNThUb0MzMihiNThjaGVjaywgdmVyc2lvbiA9IC0xKSB7XG4gICAgY29uc3QgYWRkckluZm8gPSBiYXNlNThjaGVjay5kZWNvZGUoYjU4Y2hlY2spO1xuICAgIGNvbnN0IGhhc2gxNjBTdHJpbmcgPSAoMCwgdXRpbHNfMS5ieXRlc1RvSGV4KShhZGRySW5mby5kYXRhKTtcbiAgICBjb25zdCBhZGRyVmVyc2lvbiA9IHBhcnNlSW50KCgwLCB1dGlsc18xLmJ5dGVzVG9IZXgpKGFkZHJJbmZvLnByZWZpeCksIDE2KTtcbiAgICBsZXQgc3RhY2tzVmVyc2lvbjtcbiAgICBpZiAodmVyc2lvbiA8IDApIHtcbiAgICAgICAgc3RhY2tzVmVyc2lvbiA9IGFkZHJWZXJzaW9uO1xuICAgICAgICBpZiAoQUREUl9CSVRDT0lOX1RPX1NUQUNLU1thZGRyVmVyc2lvbl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3RhY2tzVmVyc2lvbiA9IEFERFJfQklUQ09JTl9UT19TVEFDS1NbYWRkclZlcnNpb25dO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdGFja3NWZXJzaW9uID0gdmVyc2lvbjtcbiAgICB9XG4gICAgcmV0dXJuIGMzMmFkZHJlc3Moc3RhY2tzVmVyc2lvbiwgaGFzaDE2MFN0cmluZyk7XG59XG5leHBvcnRzLmI1OFRvQzMyID0gYjU4VG9DMzI7XG4vKlxuICogQ29udmVydCBhIGMzMmNoZWNrIGFkZHJlc3MgdG8gYSBiYXNlNThjaGVjayBhZGRyZXNzLlxuICogQHBhcmFtIHtzdHJpbmd9IGMzMnN0cmluZyAtIHRoZSBjMzJjaGVjayBhZGRyZXNzXG4gKiBAcGFyYW0ge251bWJlcn0gdmVyc2lvbiAtIHRoZSB2ZXJzaW9uIG51bWJlciwgaWYgbm90IGluZmVycmVkIGZyb20gdGhlIGFkZHJlc3NcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBiYXNlNTggYWRkcmVzcyB3aXRoIHRoZSBnaXZlbiB2ZXJzaW9uIG51bWJlciAob3IgdGhlXG4gKiAgICBzZW1hbnRpY2FsbHktZXF1aXZhbGVudCBiaXRjb2luIHZlcnNpb24gbnVtYmVyLCBpZiBub3QgZ2l2ZW4pXG4gKi9cbmZ1bmN0aW9uIGMzMlRvQjU4KGMzMnN0cmluZywgdmVyc2lvbiA9IC0xKSB7XG4gICAgY29uc3QgYWRkckluZm8gPSBjMzJhZGRyZXNzRGVjb2RlKGMzMnN0cmluZyk7XG4gICAgY29uc3Qgc3RhY2tzVmVyc2lvbiA9IGFkZHJJbmZvWzBdO1xuICAgIGNvbnN0IGhhc2gxNjBTdHJpbmcgPSBhZGRySW5mb1sxXTtcbiAgICBsZXQgYml0Y29pblZlcnNpb247XG4gICAgaWYgKHZlcnNpb24gPCAwKSB7XG4gICAgICAgIGJpdGNvaW5WZXJzaW9uID0gc3RhY2tzVmVyc2lvbjtcbiAgICAgICAgaWYgKEFERFJfU1RBQ0tTX1RPX0JJVENPSU5bc3RhY2tzVmVyc2lvbl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYml0Y29pblZlcnNpb24gPSBBRERSX1NUQUNLU19UT19CSVRDT0lOW3N0YWNrc1ZlcnNpb25dO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBiaXRjb2luVmVyc2lvbiA9IHZlcnNpb247XG4gICAgfVxuICAgIGxldCBwcmVmaXggPSBiaXRjb2luVmVyc2lvbi50b1N0cmluZygxNik7XG4gICAgaWYgKHByZWZpeC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcHJlZml4ID0gYDAke3ByZWZpeH1gO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZTU4Y2hlY2suZW5jb2RlKGhhc2gxNjBTdHJpbmcsIHByZWZpeCk7XG59XG5leHBvcnRzLmMzMlRvQjU4ID0gYzMyVG9CNTg7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJjMzJUb0I1OCIsImI1OFRvQzMyIiwiYzMyYWRkcmVzc0RlY29kZSIsImMzMmFkZHJlc3MiLCJ2ZXJzaW9ucyIsImNoZWNrc3VtXzEiLCJyZXF1aXJlIiwiYmFzZTU4Y2hlY2siLCJ1dGlsc18xIiwibWFpbm5ldCIsInAycGtoIiwicDJzaCIsInRlc3RuZXQiLCJBRERSX0JJVENPSU5fVE9fU1RBQ0tTIiwiQUREUl9TVEFDS1NfVE9fQklUQ09JTiIsInZlcnNpb24iLCJoYXNoMTYwaGV4IiwibWF0Y2giLCJFcnJvciIsImMzMnN0cmluZyIsImMzMmNoZWNrRW5jb2RlIiwiYzMyYWRkciIsImxlbmd0aCIsImMzMmNoZWNrRGVjb2RlIiwic2xpY2UiLCJiNThjaGVjayIsImFkZHJJbmZvIiwiZGVjb2RlIiwiaGFzaDE2MFN0cmluZyIsImJ5dGVzVG9IZXgiLCJkYXRhIiwiYWRkclZlcnNpb24iLCJwYXJzZUludCIsInByZWZpeCIsInN0YWNrc1ZlcnNpb24iLCJ1bmRlZmluZWQiLCJiaXRjb2luVmVyc2lvbiIsInRvU3RyaW5nIiwiZW5jb2RlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/c32check/lib/address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/c32check/lib/base58check.js":
/*!**************************************************!*\
  !*** ./node_modules/c32check/lib/base58check.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*\n * From https://github.com/wzbg/base58check\n * @Author: zyc\n * @Date:   2016-09-11 23:36:05\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.decode = exports.encode = void 0;\nconst sha256_1 = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@noble/hashes/sha256.js\");\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/utils.js\");\nconst basex = __webpack_require__(/*! base-x */ \"(ssr)/./node_modules/c32check/node_modules/base-x/src/index.js\");\nconst ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nfunction encode(data, prefix = \"00\") {\n    const dataBytes = typeof data === \"string\" ? (0, utils_1.hexToBytes)(data) : data;\n    const prefixBytes = typeof prefix === \"string\" ? (0, utils_1.hexToBytes)(prefix) : data;\n    if (!(dataBytes instanceof Uint8Array) || !(prefixBytes instanceof Uint8Array)) {\n        throw new TypeError(\"Argument must be of type Uint8Array or string\");\n    }\n    const checksum = (0, sha256_1.sha256)((0, sha256_1.sha256)(new Uint8Array([\n        ...prefixBytes,\n        ...dataBytes\n    ])));\n    return basex(ALPHABET).encode([\n        ...prefixBytes,\n        ...dataBytes,\n        ...checksum.slice(0, 4)\n    ]);\n}\nexports.encode = encode;\nfunction decode(string) {\n    const bytes = basex(ALPHABET).decode(string);\n    const prefixBytes = bytes.slice(0, 1);\n    const dataBytes = bytes.slice(1, -4);\n    // todo: for better performance replace spread with `concatBytes` method\n    const checksum = (0, sha256_1.sha256)((0, sha256_1.sha256)(new Uint8Array([\n        ...prefixBytes,\n        ...dataBytes\n    ])));\n    bytes.slice(-4).forEach((check, index)=>{\n        if (check !== checksum[index]) {\n            throw new Error(\"Invalid checksum\");\n        }\n    });\n    return {\n        prefix: prefixBytes,\n        data: dataBytes\n    };\n}\nexports.decode = decode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYzMyY2hlY2svbGliL2Jhc2U1OGNoZWNrLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7O0NBSUMsR0FDRDtBQUNBQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsY0FBYyxHQUFHQSxjQUFjLEdBQUcsS0FBSztBQUN2QyxNQUFNSSxXQUFXQyxtQkFBT0EsQ0FBQywwRUFBc0I7QUFDL0MsTUFBTUMsVUFBVUQsbUJBQU9BLENBQUMsd0VBQXFCO0FBQzdDLE1BQU1FLFFBQVFGLG1CQUFPQSxDQUFDLDhFQUFRO0FBQzlCLE1BQU1HLFdBQVc7QUFDakIsU0FBU0wsT0FBT00sSUFBSSxFQUFFQyxTQUFTLElBQUk7SUFDL0IsTUFBTUMsWUFBWSxPQUFPRixTQUFTLFdBQVcsQ0FBQyxHQUFHSCxRQUFRTSxVQUFVLEVBQUVILFFBQVFBO0lBQzdFLE1BQU1JLGNBQWMsT0FBT0gsV0FBVyxXQUFXLENBQUMsR0FBR0osUUFBUU0sVUFBVSxFQUFFRixVQUFVRDtJQUNuRixJQUFJLENBQUVFLENBQUFBLHFCQUFxQkcsVUFBUyxLQUFNLENBQUVELENBQUFBLHVCQUF1QkMsVUFBUyxHQUFJO1FBQzVFLE1BQU0sSUFBSUMsVUFBVTtJQUN4QjtJQUNBLE1BQU1DLFdBQVcsQ0FBQyxHQUFHWixTQUFTYSxNQUFNLEVBQUUsQ0FBQyxHQUFHYixTQUFTYSxNQUFNLEVBQUUsSUFBSUgsV0FBVztXQUFJRDtXQUFnQkY7S0FBVTtJQUN4RyxPQUFPSixNQUFNQyxVQUFVTCxNQUFNLENBQUM7V0FBSVU7V0FBZ0JGO1dBQWNLLFNBQVNFLEtBQUssQ0FBQyxHQUFHO0tBQUc7QUFDekY7QUFDQWxCLGNBQWMsR0FBR0c7QUFDakIsU0FBU0QsT0FBT2lCLE1BQU07SUFDbEIsTUFBTUMsUUFBUWIsTUFBTUMsVUFBVU4sTUFBTSxDQUFDaUI7SUFDckMsTUFBTU4sY0FBY08sTUFBTUYsS0FBSyxDQUFDLEdBQUc7SUFDbkMsTUFBTVAsWUFBWVMsTUFBTUYsS0FBSyxDQUFDLEdBQUcsQ0FBQztJQUNsQyx3RUFBd0U7SUFDeEUsTUFBTUYsV0FBVyxDQUFDLEdBQUdaLFNBQVNhLE1BQU0sRUFBRSxDQUFDLEdBQUdiLFNBQVNhLE1BQU0sRUFBRSxJQUFJSCxXQUFXO1dBQUlEO1dBQWdCRjtLQUFVO0lBQ3hHUyxNQUFNRixLQUFLLENBQUMsQ0FBQyxHQUFHRyxPQUFPLENBQUMsQ0FBQ0MsT0FBT0M7UUFDNUIsSUFBSUQsVUFBVU4sUUFBUSxDQUFDTyxNQUFNLEVBQUU7WUFDM0IsTUFBTSxJQUFJQyxNQUFNO1FBQ3BCO0lBQ0o7SUFDQSxPQUFPO1FBQUVkLFFBQVFHO1FBQWFKLE1BQU1FO0lBQVU7QUFDbEQ7QUFDQVgsY0FBYyxHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZlcmlmaWVkLWRleC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9jMzJjaGVjay9saWIvYmFzZTU4Y2hlY2suanM/ZDllOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogRnJvbSBodHRwczovL2dpdGh1Yi5jb20vd3piZy9iYXNlNThjaGVja1xuICogQEF1dGhvcjogenljXG4gKiBARGF0ZTogICAyMDE2LTA5LTExIDIzOjM2OjA1XG4gKi9cbid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5lbmNvZGUgPSB2b2lkIDA7XG5jb25zdCBzaGEyNTZfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3NoYTI1NlwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiKTtcbmNvbnN0IGJhc2V4ID0gcmVxdWlyZShcImJhc2UteFwiKTtcbmNvbnN0IEFMUEhBQkVUID0gJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonO1xuZnVuY3Rpb24gZW5jb2RlKGRhdGEsIHByZWZpeCA9ICcwMCcpIHtcbiAgICBjb25zdCBkYXRhQnl0ZXMgPSB0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgPyAoMCwgdXRpbHNfMS5oZXhUb0J5dGVzKShkYXRhKSA6IGRhdGE7XG4gICAgY29uc3QgcHJlZml4Qnl0ZXMgPSB0eXBlb2YgcHJlZml4ID09PSAnc3RyaW5nJyA/ICgwLCB1dGlsc18xLmhleFRvQnl0ZXMpKHByZWZpeCkgOiBkYXRhO1xuICAgIGlmICghKGRhdGFCeXRlcyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHx8ICEocHJlZml4Qnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgVWludDhBcnJheSBvciBzdHJpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgY2hlY2tzdW0gPSAoMCwgc2hhMjU2XzEuc2hhMjU2KSgoMCwgc2hhMjU2XzEuc2hhMjU2KShuZXcgVWludDhBcnJheShbLi4ucHJlZml4Qnl0ZXMsIC4uLmRhdGFCeXRlc10pKSk7XG4gICAgcmV0dXJuIGJhc2V4KEFMUEhBQkVUKS5lbmNvZGUoWy4uLnByZWZpeEJ5dGVzLCAuLi5kYXRhQnl0ZXMsIC4uLmNoZWNrc3VtLnNsaWNlKDAsIDQpXSk7XG59XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbmZ1bmN0aW9uIGRlY29kZShzdHJpbmcpIHtcbiAgICBjb25zdCBieXRlcyA9IGJhc2V4KEFMUEhBQkVUKS5kZWNvZGUoc3RyaW5nKTtcbiAgICBjb25zdCBwcmVmaXhCeXRlcyA9IGJ5dGVzLnNsaWNlKDAsIDEpO1xuICAgIGNvbnN0IGRhdGFCeXRlcyA9IGJ5dGVzLnNsaWNlKDEsIC00KTtcbiAgICAvLyB0b2RvOiBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlIHJlcGxhY2Ugc3ByZWFkIHdpdGggYGNvbmNhdEJ5dGVzYCBtZXRob2RcbiAgICBjb25zdCBjaGVja3N1bSA9ICgwLCBzaGEyNTZfMS5zaGEyNTYpKCgwLCBzaGEyNTZfMS5zaGEyNTYpKG5ldyBVaW50OEFycmF5KFsuLi5wcmVmaXhCeXRlcywgLi4uZGF0YUJ5dGVzXSkpKTtcbiAgICBieXRlcy5zbGljZSgtNCkuZm9yRWFjaCgoY2hlY2ssIGluZGV4KSA9PiB7XG4gICAgICAgIGlmIChjaGVjayAhPT0gY2hlY2tzdW1baW5kZXhdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY2hlY2tzdW0nKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7IHByZWZpeDogcHJlZml4Qnl0ZXMsIGRhdGE6IGRhdGFCeXRlcyB9O1xufVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWNvZGUiLCJlbmNvZGUiLCJzaGEyNTZfMSIsInJlcXVpcmUiLCJ1dGlsc18xIiwiYmFzZXgiLCJBTFBIQUJFVCIsImRhdGEiLCJwcmVmaXgiLCJkYXRhQnl0ZXMiLCJoZXhUb0J5dGVzIiwicHJlZml4Qnl0ZXMiLCJVaW50OEFycmF5IiwiVHlwZUVycm9yIiwiY2hlY2tzdW0iLCJzaGEyNTYiLCJzbGljZSIsInN0cmluZyIsImJ5dGVzIiwiZm9yRWFjaCIsImNoZWNrIiwiaW5kZXgiLCJFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/c32check/lib/base58check.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/c32check/lib/checksum.js":
/*!***********************************************!*\
  !*** ./node_modules/c32check/lib/checksum.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.c32checkDecode = exports.c32checkEncode = void 0;\nconst sha256_1 = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@noble/hashes/sha256.js\");\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/utils.js\");\nconst encoding_1 = __webpack_require__(/*! ./encoding */ \"(ssr)/./node_modules/c32check/lib/encoding.js\");\n/**\n * Get the c32check checksum of a hex-encoded string\n * @param {string} dataHex - the hex string\n * @returns {string} the c32 checksum, as a bin-encoded string\n */ function c32checksum(dataHex) {\n    const dataHash = (0, sha256_1.sha256)((0, sha256_1.sha256)((0, utils_1.hexToBytes)(dataHex)));\n    const checksum = (0, utils_1.bytesToHex)(dataHash.slice(0, 4));\n    return checksum;\n}\n/**\n * Encode a hex string as a c32check string.  This is a lot like how\n * base58check works in Bitcoin-land, but this algorithm uses the\n * z-base-32 alphabet instead of the base58 alphabet.  The algorithm\n * is as follows:\n * * calculate the c32checksum of version + data\n * * c32encode version + data + c32checksum\n * @param {number} version - the version string (between 0 and 31)\n * @param {string} data - the data to encode\n * @returns {string} the c32check representation\n */ function c32checkEncode(version, data) {\n    if (version < 0 || version >= 32) {\n        throw new Error(\"Invalid version (must be between 0 and 31)\");\n    }\n    if (!data.match(/^[0-9a-fA-F]*$/)) {\n        throw new Error(\"Invalid data (not a hex string)\");\n    }\n    data = data.toLowerCase();\n    if (data.length % 2 !== 0) {\n        data = `0${data}`;\n    }\n    let versionHex = version.toString(16);\n    if (versionHex.length === 1) {\n        versionHex = `0${versionHex}`;\n    }\n    const checksumHex = c32checksum(`${versionHex}${data}`);\n    const c32str = (0, encoding_1.c32encode)(`${data}${checksumHex}`);\n    return `${encoding_1.c32[version]}${c32str}`;\n}\nexports.c32checkEncode = c32checkEncode;\n/*\n * Decode a c32check string back into its version and data payload.  This is\n * a lot like how base58check works in Bitcoin-land, but this algorithm uses\n * the z-base-32 alphabet instead of the base58 alphabet.  The algorithm\n * is as follows:\n * * extract the version, data, and checksum\n * * verify the checksum matches c32checksum(version + data)\n * * return data\n * @param {string} c32data - the c32check-encoded string\n * @returns {array} [version (number), data (string)].  The returned data\n * will be a hex string.  Throws an exception if the checksum does not match.\n */ function c32checkDecode(c32data) {\n    c32data = (0, encoding_1.c32normalize)(c32data);\n    const dataHex = (0, encoding_1.c32decode)(c32data.slice(1));\n    const versionChar = c32data[0];\n    const version = encoding_1.c32.indexOf(versionChar);\n    const checksum = dataHex.slice(-8);\n    let versionHex = version.toString(16);\n    if (versionHex.length === 1) {\n        versionHex = `0${versionHex}`;\n    }\n    if (c32checksum(`${versionHex}${dataHex.substring(0, dataHex.length - 8)}`) !== checksum) {\n        throw new Error(\"Invalid c32check string: checksum mismatch\");\n    }\n    return [\n        version,\n        dataHex.substring(0, dataHex.length - 8)\n    ];\n}\nexports.c32checkDecode = c32checkDecode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYzMyY2hlY2svbGliL2NoZWNrc3VtLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxzQkFBc0IsR0FBR0Esc0JBQXNCLEdBQUcsS0FBSztBQUN2RCxNQUFNSSxXQUFXQyxtQkFBT0EsQ0FBQywwRUFBc0I7QUFDL0MsTUFBTUMsVUFBVUQsbUJBQU9BLENBQUMsd0VBQXFCO0FBQzdDLE1BQU1FLGFBQWFGLG1CQUFPQSxDQUFDLGlFQUFZO0FBQ3ZDOzs7O0NBSUMsR0FDRCxTQUFTRyxZQUFZQyxPQUFPO0lBQ3hCLE1BQU1DLFdBQVcsQ0FBQyxHQUFHTixTQUFTTyxNQUFNLEVBQUUsQ0FBQyxHQUFHUCxTQUFTTyxNQUFNLEVBQUUsQ0FBQyxHQUFHTCxRQUFRTSxVQUFVLEVBQUVIO0lBQ25GLE1BQU1JLFdBQVcsQ0FBQyxHQUFHUCxRQUFRUSxVQUFVLEVBQUVKLFNBQVNLLEtBQUssQ0FBQyxHQUFHO0lBQzNELE9BQU9GO0FBQ1g7QUFDQTs7Ozs7Ozs7OztDQVVDLEdBQ0QsU0FBU1YsZUFBZWEsT0FBTyxFQUFFQyxJQUFJO0lBQ2pDLElBQUlELFVBQVUsS0FBS0EsV0FBVyxJQUFJO1FBQzlCLE1BQU0sSUFBSUUsTUFBTTtJQUNwQjtJQUNBLElBQUksQ0FBQ0QsS0FBS0UsS0FBSyxDQUFDLG1CQUFtQjtRQUMvQixNQUFNLElBQUlELE1BQU07SUFDcEI7SUFDQUQsT0FBT0EsS0FBS0csV0FBVztJQUN2QixJQUFJSCxLQUFLSSxNQUFNLEdBQUcsTUFBTSxHQUFHO1FBQ3ZCSixPQUFPLENBQUMsQ0FBQyxFQUFFQSxLQUFLLENBQUM7SUFDckI7SUFDQSxJQUFJSyxhQUFhTixRQUFRTyxRQUFRLENBQUM7SUFDbEMsSUFBSUQsV0FBV0QsTUFBTSxLQUFLLEdBQUc7UUFDekJDLGFBQWEsQ0FBQyxDQUFDLEVBQUVBLFdBQVcsQ0FBQztJQUNqQztJQUNBLE1BQU1FLGNBQWNoQixZQUFZLENBQUMsRUFBRWMsV0FBVyxFQUFFTCxLQUFLLENBQUM7SUFDdEQsTUFBTVEsU0FBUyxDQUFDLEdBQUdsQixXQUFXbUIsU0FBUyxFQUFFLENBQUMsRUFBRVQsS0FBSyxFQUFFTyxZQUFZLENBQUM7SUFDaEUsT0FBTyxDQUFDLEVBQUVqQixXQUFXb0IsR0FBRyxDQUFDWCxRQUFRLENBQUMsRUFBRVMsT0FBTyxDQUFDO0FBQ2hEO0FBQ0F6QixzQkFBc0IsR0FBR0c7QUFDekI7Ozs7Ozs7Ozs7O0NBV0MsR0FDRCxTQUFTRCxlQUFlMEIsT0FBTztJQUMzQkEsVUFBVSxDQUFDLEdBQUdyQixXQUFXc0IsWUFBWSxFQUFFRDtJQUN2QyxNQUFNbkIsVUFBVSxDQUFDLEdBQUdGLFdBQVd1QixTQUFTLEVBQUVGLFFBQVFiLEtBQUssQ0FBQztJQUN4RCxNQUFNZ0IsY0FBY0gsT0FBTyxDQUFDLEVBQUU7SUFDOUIsTUFBTVosVUFBVVQsV0FBV29CLEdBQUcsQ0FBQ0ssT0FBTyxDQUFDRDtJQUN2QyxNQUFNbEIsV0FBV0osUUFBUU0sS0FBSyxDQUFDLENBQUM7SUFDaEMsSUFBSU8sYUFBYU4sUUFBUU8sUUFBUSxDQUFDO0lBQ2xDLElBQUlELFdBQVdELE1BQU0sS0FBSyxHQUFHO1FBQ3pCQyxhQUFhLENBQUMsQ0FBQyxFQUFFQSxXQUFXLENBQUM7SUFDakM7SUFDQSxJQUFJZCxZQUFZLENBQUMsRUFBRWMsV0FBVyxFQUFFYixRQUFRd0IsU0FBUyxDQUFDLEdBQUd4QixRQUFRWSxNQUFNLEdBQUcsR0FBRyxDQUFDLE1BQU1SLFVBQVU7UUFDdEYsTUFBTSxJQUFJSyxNQUFNO0lBQ3BCO0lBQ0EsT0FBTztRQUFDRjtRQUFTUCxRQUFRd0IsU0FBUyxDQUFDLEdBQUd4QixRQUFRWSxNQUFNLEdBQUc7S0FBRztBQUM5RDtBQUNBckIsc0JBQXNCLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmVyaWZpZWQtZGV4LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2MzMmNoZWNrL2xpYi9jaGVja3N1bS5qcz84Y2YwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jMzJjaGVja0RlY29kZSA9IGV4cG9ydHMuYzMyY2hlY2tFbmNvZGUgPSB2b2lkIDA7XG5jb25zdCBzaGEyNTZfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3NoYTI1NlwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiKTtcbmNvbnN0IGVuY29kaW5nXzEgPSByZXF1aXJlKFwiLi9lbmNvZGluZ1wiKTtcbi8qKlxuICogR2V0IHRoZSBjMzJjaGVjayBjaGVja3N1bSBvZiBhIGhleC1lbmNvZGVkIHN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IGRhdGFIZXggLSB0aGUgaGV4IHN0cmluZ1xuICogQHJldHVybnMge3N0cmluZ30gdGhlIGMzMiBjaGVja3N1bSwgYXMgYSBiaW4tZW5jb2RlZCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gYzMyY2hlY2tzdW0oZGF0YUhleCkge1xuICAgIGNvbnN0IGRhdGFIYXNoID0gKDAsIHNoYTI1Nl8xLnNoYTI1NikoKDAsIHNoYTI1Nl8xLnNoYTI1NikoKDAsIHV0aWxzXzEuaGV4VG9CeXRlcykoZGF0YUhleCkpKTtcbiAgICBjb25zdCBjaGVja3N1bSA9ICgwLCB1dGlsc18xLmJ5dGVzVG9IZXgpKGRhdGFIYXNoLnNsaWNlKDAsIDQpKTtcbiAgICByZXR1cm4gY2hlY2tzdW07XG59XG4vKipcbiAqIEVuY29kZSBhIGhleCBzdHJpbmcgYXMgYSBjMzJjaGVjayBzdHJpbmcuICBUaGlzIGlzIGEgbG90IGxpa2UgaG93XG4gKiBiYXNlNThjaGVjayB3b3JrcyBpbiBCaXRjb2luLWxhbmQsIGJ1dCB0aGlzIGFsZ29yaXRobSB1c2VzIHRoZVxuICogei1iYXNlLTMyIGFscGhhYmV0IGluc3RlYWQgb2YgdGhlIGJhc2U1OCBhbHBoYWJldC4gIFRoZSBhbGdvcml0aG1cbiAqIGlzIGFzIGZvbGxvd3M6XG4gKiAqIGNhbGN1bGF0ZSB0aGUgYzMyY2hlY2tzdW0gb2YgdmVyc2lvbiArIGRhdGFcbiAqICogYzMyZW5jb2RlIHZlcnNpb24gKyBkYXRhICsgYzMyY2hlY2tzdW1cbiAqIEBwYXJhbSB7bnVtYmVyfSB2ZXJzaW9uIC0gdGhlIHZlcnNpb24gc3RyaW5nIChiZXR3ZWVuIDAgYW5kIDMxKVxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgLSB0aGUgZGF0YSB0byBlbmNvZGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBjMzJjaGVjayByZXByZXNlbnRhdGlvblxuICovXG5mdW5jdGlvbiBjMzJjaGVja0VuY29kZSh2ZXJzaW9uLCBkYXRhKSB7XG4gICAgaWYgKHZlcnNpb24gPCAwIHx8IHZlcnNpb24gPj0gMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZlcnNpb24gKG11c3QgYmUgYmV0d2VlbiAwIGFuZCAzMSknKTtcbiAgICB9XG4gICAgaWYgKCFkYXRhLm1hdGNoKC9eWzAtOWEtZkEtRl0qJC8pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkYXRhIChub3QgYSBoZXggc3RyaW5nKScpO1xuICAgIH1cbiAgICBkYXRhID0gZGF0YS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChkYXRhLmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgICAgZGF0YSA9IGAwJHtkYXRhfWA7XG4gICAgfVxuICAgIGxldCB2ZXJzaW9uSGV4ID0gdmVyc2lvbi50b1N0cmluZygxNik7XG4gICAgaWYgKHZlcnNpb25IZXgubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHZlcnNpb25IZXggPSBgMCR7dmVyc2lvbkhleH1gO1xuICAgIH1cbiAgICBjb25zdCBjaGVja3N1bUhleCA9IGMzMmNoZWNrc3VtKGAke3ZlcnNpb25IZXh9JHtkYXRhfWApO1xuICAgIGNvbnN0IGMzMnN0ciA9ICgwLCBlbmNvZGluZ18xLmMzMmVuY29kZSkoYCR7ZGF0YX0ke2NoZWNrc3VtSGV4fWApO1xuICAgIHJldHVybiBgJHtlbmNvZGluZ18xLmMzMlt2ZXJzaW9uXX0ke2MzMnN0cn1gO1xufVxuZXhwb3J0cy5jMzJjaGVja0VuY29kZSA9IGMzMmNoZWNrRW5jb2RlO1xuLypcbiAqIERlY29kZSBhIGMzMmNoZWNrIHN0cmluZyBiYWNrIGludG8gaXRzIHZlcnNpb24gYW5kIGRhdGEgcGF5bG9hZC4gIFRoaXMgaXNcbiAqIGEgbG90IGxpa2UgaG93IGJhc2U1OGNoZWNrIHdvcmtzIGluIEJpdGNvaW4tbGFuZCwgYnV0IHRoaXMgYWxnb3JpdGhtIHVzZXNcbiAqIHRoZSB6LWJhc2UtMzIgYWxwaGFiZXQgaW5zdGVhZCBvZiB0aGUgYmFzZTU4IGFscGhhYmV0LiAgVGhlIGFsZ29yaXRobVxuICogaXMgYXMgZm9sbG93czpcbiAqICogZXh0cmFjdCB0aGUgdmVyc2lvbiwgZGF0YSwgYW5kIGNoZWNrc3VtXG4gKiAqIHZlcmlmeSB0aGUgY2hlY2tzdW0gbWF0Y2hlcyBjMzJjaGVja3N1bSh2ZXJzaW9uICsgZGF0YSlcbiAqICogcmV0dXJuIGRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBjMzJkYXRhIC0gdGhlIGMzMmNoZWNrLWVuY29kZWQgc3RyaW5nXG4gKiBAcmV0dXJucyB7YXJyYXl9IFt2ZXJzaW9uIChudW1iZXIpLCBkYXRhIChzdHJpbmcpXS4gIFRoZSByZXR1cm5lZCBkYXRhXG4gKiB3aWxsIGJlIGEgaGV4IHN0cmluZy4gIFRocm93cyBhbiBleGNlcHRpb24gaWYgdGhlIGNoZWNrc3VtIGRvZXMgbm90IG1hdGNoLlxuICovXG5mdW5jdGlvbiBjMzJjaGVja0RlY29kZShjMzJkYXRhKSB7XG4gICAgYzMyZGF0YSA9ICgwLCBlbmNvZGluZ18xLmMzMm5vcm1hbGl6ZSkoYzMyZGF0YSk7XG4gICAgY29uc3QgZGF0YUhleCA9ICgwLCBlbmNvZGluZ18xLmMzMmRlY29kZSkoYzMyZGF0YS5zbGljZSgxKSk7XG4gICAgY29uc3QgdmVyc2lvbkNoYXIgPSBjMzJkYXRhWzBdO1xuICAgIGNvbnN0IHZlcnNpb24gPSBlbmNvZGluZ18xLmMzMi5pbmRleE9mKHZlcnNpb25DaGFyKTtcbiAgICBjb25zdCBjaGVja3N1bSA9IGRhdGFIZXguc2xpY2UoLTgpO1xuICAgIGxldCB2ZXJzaW9uSGV4ID0gdmVyc2lvbi50b1N0cmluZygxNik7XG4gICAgaWYgKHZlcnNpb25IZXgubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHZlcnNpb25IZXggPSBgMCR7dmVyc2lvbkhleH1gO1xuICAgIH1cbiAgICBpZiAoYzMyY2hlY2tzdW0oYCR7dmVyc2lvbkhleH0ke2RhdGFIZXguc3Vic3RyaW5nKDAsIGRhdGFIZXgubGVuZ3RoIC0gOCl9YCkgIT09IGNoZWNrc3VtKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjMzJjaGVjayBzdHJpbmc6IGNoZWNrc3VtIG1pc21hdGNoJyk7XG4gICAgfVxuICAgIHJldHVybiBbdmVyc2lvbiwgZGF0YUhleC5zdWJzdHJpbmcoMCwgZGF0YUhleC5sZW5ndGggLSA4KV07XG59XG5leHBvcnRzLmMzMmNoZWNrRGVjb2RlID0gYzMyY2hlY2tEZWNvZGU7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJjMzJjaGVja0RlY29kZSIsImMzMmNoZWNrRW5jb2RlIiwic2hhMjU2XzEiLCJyZXF1aXJlIiwidXRpbHNfMSIsImVuY29kaW5nXzEiLCJjMzJjaGVja3N1bSIsImRhdGFIZXgiLCJkYXRhSGFzaCIsInNoYTI1NiIsImhleFRvQnl0ZXMiLCJjaGVja3N1bSIsImJ5dGVzVG9IZXgiLCJzbGljZSIsInZlcnNpb24iLCJkYXRhIiwiRXJyb3IiLCJtYXRjaCIsInRvTG93ZXJDYXNlIiwibGVuZ3RoIiwidmVyc2lvbkhleCIsInRvU3RyaW5nIiwiY2hlY2tzdW1IZXgiLCJjMzJzdHIiLCJjMzJlbmNvZGUiLCJjMzIiLCJjMzJkYXRhIiwiYzMybm9ybWFsaXplIiwiYzMyZGVjb2RlIiwidmVyc2lvbkNoYXIiLCJpbmRleE9mIiwic3Vic3RyaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/c32check/lib/checksum.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/c32check/lib/encoding.js":
/*!***********************************************!*\
  !*** ./node_modules/c32check/lib/encoding.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.c32decode = exports.c32normalize = exports.c32encode = exports.c32 = void 0;\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/utils.js\");\nexports.c32 = \"0123456789ABCDEFGHJKMNPQRSTVWXYZ\";\nconst hex = \"0123456789abcdef\";\n/**\n * Encode a hex string as a c32 string.  Note that the hex string is assumed\n * to be big-endian (and the resulting c32 string will be as well).\n * @param {string} inputHex - the input to encode\n * @param {number} minLength - the minimum length of the c32 string\n * @returns {string} the c32check-encoded representation of the data, as a string\n */ function c32encode(inputHex, minLength) {\n    // must be hex\n    if (!inputHex.match(/^[0-9a-fA-F]*$/)) {\n        throw new Error(\"Not a hex-encoded string\");\n    }\n    if (inputHex.length % 2 !== 0) {\n        inputHex = `0${inputHex}`;\n    }\n    inputHex = inputHex.toLowerCase();\n    let res = [];\n    let carry = 0;\n    for(let i = inputHex.length - 1; i >= 0; i--){\n        if (carry < 4) {\n            const currentCode = hex.indexOf(inputHex[i]) >> carry;\n            let nextCode = 0;\n            if (i !== 0) {\n                nextCode = hex.indexOf(inputHex[i - 1]);\n            }\n            // carry = 0, nextBits is 1, carry = 1, nextBits is 2\n            const nextBits = 1 + carry;\n            const nextLowBits = nextCode % (1 << nextBits) << 5 - nextBits;\n            const curC32Digit = exports.c32[currentCode + nextLowBits];\n            carry = nextBits;\n            res.unshift(curC32Digit);\n        } else {\n            carry = 0;\n        }\n    }\n    let C32leadingZeros = 0;\n    for(let i = 0; i < res.length; i++){\n        if (res[i] !== \"0\") {\n            break;\n        } else {\n            C32leadingZeros++;\n        }\n    }\n    res = res.slice(C32leadingZeros);\n    const zeroPrefix = new TextDecoder().decode((0, utils_1.hexToBytes)(inputHex)).match(/^\\u0000*/);\n    const numLeadingZeroBytesInHex = zeroPrefix ? zeroPrefix[0].length : 0;\n    for(let i = 0; i < numLeadingZeroBytesInHex; i++){\n        res.unshift(exports.c32[0]);\n    }\n    if (minLength) {\n        const count = minLength - res.length;\n        for(let i = 0; i < count; i++){\n            res.unshift(exports.c32[0]);\n        }\n    }\n    return res.join(\"\");\n}\nexports.c32encode = c32encode;\n/*\n * Normalize a c32 string\n * @param {string} c32input - the c32-encoded input string\n * @returns {string} the canonical representation of the c32 input string\n */ function c32normalize(c32input) {\n    // must be upper-case\n    // replace all O's with 0's\n    // replace all I's and L's with 1's\n    return c32input.toUpperCase().replace(/O/g, \"0\").replace(/L|I/g, \"1\");\n}\nexports.c32normalize = c32normalize;\n/*\n * Decode a c32 string back into a hex string.  Note that the c32 input\n * string is assumed to be big-endian (and the resulting hex string will\n * be as well).\n * @param {string} c32input - the c32-encoded input to decode\n * @param {number} minLength - the minimum length of the output hex string (in bytes)\n * @returns {string} the hex-encoded representation of the data, as a string\n */ function c32decode(c32input, minLength) {\n    c32input = c32normalize(c32input);\n    // must result in a c32 string\n    if (!c32input.match(`^[${exports.c32}]*$`)) {\n        throw new Error(\"Not a c32-encoded string\");\n    }\n    const zeroPrefix = c32input.match(`^${exports.c32[0]}*`);\n    const numLeadingZeroBytes = zeroPrefix ? zeroPrefix[0].length : 0;\n    let res = [];\n    let carry = 0;\n    let carryBits = 0;\n    for(let i = c32input.length - 1; i >= 0; i--){\n        if (carryBits === 4) {\n            res.unshift(hex[carry]);\n            carryBits = 0;\n            carry = 0;\n        }\n        const currentCode = exports.c32.indexOf(c32input[i]) << carryBits;\n        const currentValue = currentCode + carry;\n        const currentHexDigit = hex[currentValue % 16];\n        carryBits += 1;\n        carry = currentValue >> 4;\n        if (carry > 1 << carryBits) {\n            throw new Error(\"Panic error in decoding.\");\n        }\n        res.unshift(currentHexDigit);\n    }\n    // one last carry\n    res.unshift(hex[carry]);\n    if (res.length % 2 === 1) {\n        res.unshift(\"0\");\n    }\n    let hexLeadingZeros = 0;\n    for(let i = 0; i < res.length; i++){\n        if (res[i] !== \"0\") {\n            break;\n        } else {\n            hexLeadingZeros++;\n        }\n    }\n    res = res.slice(hexLeadingZeros - hexLeadingZeros % 2);\n    let hexStr = res.join(\"\");\n    for(let i = 0; i < numLeadingZeroBytes; i++){\n        hexStr = `00${hexStr}`;\n    }\n    if (minLength) {\n        const count = minLength * 2 - hexStr.length;\n        for(let i = 0; i < count; i += 2){\n            hexStr = `00${hexStr}`;\n        }\n    }\n    return hexStr;\n}\nexports.c32decode = c32decode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYzMyY2hlY2svbGliL2VuY29kaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxpQkFBaUIsR0FBR0Esb0JBQW9CLEdBQUdBLGlCQUFpQixHQUFHQSxXQUFXLEdBQUcsS0FBSztBQUNsRixNQUFNTSxVQUFVQyxtQkFBT0EsQ0FBQyx3RUFBcUI7QUFDN0NQLFdBQVcsR0FBRztBQUNkLE1BQU1RLE1BQU07QUFDWjs7Ozs7O0NBTUMsR0FDRCxTQUFTSixVQUFVSyxRQUFRLEVBQUVDLFNBQVM7SUFDbEMsY0FBYztJQUNkLElBQUksQ0FBQ0QsU0FBU0UsS0FBSyxDQUFDLG1CQUFtQjtRQUNuQyxNQUFNLElBQUlDLE1BQU07SUFDcEI7SUFDQSxJQUFJSCxTQUFTSSxNQUFNLEdBQUcsTUFBTSxHQUFHO1FBQzNCSixXQUFXLENBQUMsQ0FBQyxFQUFFQSxTQUFTLENBQUM7SUFDN0I7SUFDQUEsV0FBV0EsU0FBU0ssV0FBVztJQUMvQixJQUFJQyxNQUFNLEVBQUU7SUFDWixJQUFJQyxRQUFRO0lBQ1osSUFBSyxJQUFJQyxJQUFJUixTQUFTSSxNQUFNLEdBQUcsR0FBR0ksS0FBSyxHQUFHQSxJQUFLO1FBQzNDLElBQUlELFFBQVEsR0FBRztZQUNYLE1BQU1FLGNBQWNWLElBQUlXLE9BQU8sQ0FBQ1YsUUFBUSxDQUFDUSxFQUFFLEtBQUtEO1lBQ2hELElBQUlJLFdBQVc7WUFDZixJQUFJSCxNQUFNLEdBQUc7Z0JBQ1RHLFdBQVdaLElBQUlXLE9BQU8sQ0FBQ1YsUUFBUSxDQUFDUSxJQUFJLEVBQUU7WUFDMUM7WUFDQSxxREFBcUQ7WUFDckQsTUFBTUksV0FBVyxJQUFJTDtZQUNyQixNQUFNTSxjQUFjRixXQUFZLE1BQUtDLFFBQU8sS0FBTyxJQUFJQTtZQUN2RCxNQUFNRSxjQUFjdkIsUUFBUUssR0FBRyxDQUFDYSxjQUFjSSxZQUFZO1lBQzFETixRQUFRSztZQUNS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dEIsSUFBSyxJQUFJeEIsSUFBSSxHQUFHQSxJQUFJRixJQUFJRixNQUFNLEVBQUVJLElBQUs7UUFDakMsSUFBSUYsR0FBRyxDQUFDRSxFQUFFLEtBQUssS0FBSztZQUNoQjtRQUNKLE9BQ0s7WUFDRHdCO1FBQ0o7SUFDSjtJQUNBMUIsTUFBTUEsSUFBSVcsS0FBSyxDQUFDZSxrQkFBbUJBLGtCQUFrQjtJQUNyRCxJQUFJQyxTQUFTM0IsSUFBSWtCLElBQUksQ0FBQztJQUN0QixJQUFLLElBQUloQixJQUFJLEdBQUdBLElBQUlvQixxQkFBcUJwQixJQUFLO1FBQzFDeUIsU0FBUyxDQUFDLEVBQUUsRUFBRUEsT0FBTyxDQUFDO0lBQzFCO0lBQ0EsSUFBSWhDLFdBQVc7UUFDWCxNQUFNc0IsUUFBUXRCLFlBQVksSUFBSWdDLE9BQU83QixNQUFNO1FBQzNDLElBQUssSUFBSUksSUFBSSxHQUFHQSxJQUFJZSxPQUFPZixLQUFLLEVBQUc7WUFDL0J5QixTQUFTLENBQUMsRUFBRSxFQUFFQSxPQUFPLENBQUM7UUFDMUI7SUFDSjtJQUNBLE9BQU9BO0FBQ1g7QUFDQTFDLGlCQUFpQixHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZlcmlmaWVkLWRleC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9jMzJjaGVjay9saWIvZW5jb2RpbmcuanM/NWQ1NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYzMyZGVjb2RlID0gZXhwb3J0cy5jMzJub3JtYWxpemUgPSBleHBvcnRzLmMzMmVuY29kZSA9IGV4cG9ydHMuYzMyID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCIpO1xuZXhwb3J0cy5jMzIgPSAnMDEyMzQ1Njc4OUFCQ0RFRkdISktNTlBRUlNUVldYWVonO1xuY29uc3QgaGV4ID0gJzAxMjM0NTY3ODlhYmNkZWYnO1xuLyoqXG4gKiBFbmNvZGUgYSBoZXggc3RyaW5nIGFzIGEgYzMyIHN0cmluZy4gIE5vdGUgdGhhdCB0aGUgaGV4IHN0cmluZyBpcyBhc3N1bWVkXG4gKiB0byBiZSBiaWctZW5kaWFuIChhbmQgdGhlIHJlc3VsdGluZyBjMzIgc3RyaW5nIHdpbGwgYmUgYXMgd2VsbCkuXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRIZXggLSB0aGUgaW5wdXQgdG8gZW5jb2RlXG4gKiBAcGFyYW0ge251bWJlcn0gbWluTGVuZ3RoIC0gdGhlIG1pbmltdW0gbGVuZ3RoIG9mIHRoZSBjMzIgc3RyaW5nXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgYzMyY2hlY2stZW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZGF0YSwgYXMgYSBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gYzMyZW5jb2RlKGlucHV0SGV4LCBtaW5MZW5ndGgpIHtcbiAgICAvLyBtdXN0IGJlIGhleFxuICAgIGlmICghaW5wdXRIZXgubWF0Y2goL15bMC05YS1mQS1GXSokLykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYSBoZXgtZW5jb2RlZCBzdHJpbmcnKTtcbiAgICB9XG4gICAgaWYgKGlucHV0SGV4Lmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgICAgaW5wdXRIZXggPSBgMCR7aW5wdXRIZXh9YDtcbiAgICB9XG4gICAgaW5wdXRIZXggPSBpbnB1dEhleC50b0xvd2VyQ2FzZSgpO1xuICAgIGxldCByZXMgPSBbXTtcbiAgICBsZXQgY2FycnkgPSAwO1xuICAgIGZvciAobGV0IGkgPSBpbnB1dEhleC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAoY2FycnkgPCA0KSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50Q29kZSA9IGhleC5pbmRleE9mKGlucHV0SGV4W2ldKSA+PiBjYXJyeTtcbiAgICAgICAgICAgIGxldCBuZXh0Q29kZSA9IDA7XG4gICAgICAgICAgICBpZiAoaSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIG5leHRDb2RlID0gaGV4LmluZGV4T2YoaW5wdXRIZXhbaSAtIDFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNhcnJ5ID0gMCwgbmV4dEJpdHMgaXMgMSwgY2FycnkgPSAxLCBuZXh0Qml0cyBpcyAyXG4gICAgICAgICAgICBjb25zdCBuZXh0Qml0cyA9IDEgKyBjYXJyeTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRMb3dCaXRzID0gbmV4dENvZGUgJSAoMSA8PCBuZXh0Qml0cykgPDwgKDUgLSBuZXh0Qml0cyk7XG4gICAgICAgICAgICBjb25zdCBjdXJDMzJEaWdpdCA9IGV4cG9ydHMuYzMyW2N1cnJlbnRDb2RlICsgbmV4dExvd0JpdHNdO1xuICAgICAgICAgICAgY2FycnkgPSBuZXh0Qml0cztcbiAgICAgICAgICAgIHJlcy51bnNoaWZ0KGN1ckMzMkRpZ2l0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhcnJ5ID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgQzMybGVhZGluZ1plcm9zID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocmVzW2ldICE9PSAnMCcpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgQzMybGVhZGluZ1plcm9zKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzID0gcmVzLnNsaWNlKEMzMmxlYWRpbmdaZXJvcyk7XG4gICAgY29uc3QgemVyb1ByZWZpeCA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZSgoMCwgdXRpbHNfMS5oZXhUb0J5dGVzKShpbnB1dEhleCkpLm1hdGNoKC9eXFx1MDAwMCovKTtcbiAgICBjb25zdCBudW1MZWFkaW5nWmVyb0J5dGVzSW5IZXggPSB6ZXJvUHJlZml4ID8gemVyb1ByZWZpeFswXS5sZW5ndGggOiAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtTGVhZGluZ1plcm9CeXRlc0luSGV4OyBpKyspIHtcbiAgICAgICAgcmVzLnVuc2hpZnQoZXhwb3J0cy5jMzJbMF0pO1xuICAgIH1cbiAgICBpZiAobWluTGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gbWluTGVuZ3RoIC0gcmVzLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICByZXMudW5zaGlmdChleHBvcnRzLmMzMlswXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcy5qb2luKCcnKTtcbn1cbmV4cG9ydHMuYzMyZW5jb2RlID0gYzMyZW5jb2RlO1xuLypcbiAqIE5vcm1hbGl6ZSBhIGMzMiBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBjMzJpbnB1dCAtIHRoZSBjMzItZW5jb2RlZCBpbnB1dCBzdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBjYW5vbmljYWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIGMzMiBpbnB1dCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gYzMybm9ybWFsaXplKGMzMmlucHV0KSB7XG4gICAgLy8gbXVzdCBiZSB1cHBlci1jYXNlXG4gICAgLy8gcmVwbGFjZSBhbGwgTydzIHdpdGggMCdzXG4gICAgLy8gcmVwbGFjZSBhbGwgSSdzIGFuZCBMJ3Mgd2l0aCAxJ3NcbiAgICByZXR1cm4gYzMyaW5wdXQudG9VcHBlckNhc2UoKS5yZXBsYWNlKC9PL2csICcwJykucmVwbGFjZSgvTHxJL2csICcxJyk7XG59XG5leHBvcnRzLmMzMm5vcm1hbGl6ZSA9IGMzMm5vcm1hbGl6ZTtcbi8qXG4gKiBEZWNvZGUgYSBjMzIgc3RyaW5nIGJhY2sgaW50byBhIGhleCBzdHJpbmcuICBOb3RlIHRoYXQgdGhlIGMzMiBpbnB1dFxuICogc3RyaW5nIGlzIGFzc3VtZWQgdG8gYmUgYmlnLWVuZGlhbiAoYW5kIHRoZSByZXN1bHRpbmcgaGV4IHN0cmluZyB3aWxsXG4gKiBiZSBhcyB3ZWxsKS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjMzJpbnB1dCAtIHRoZSBjMzItZW5jb2RlZCBpbnB1dCB0byBkZWNvZGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5MZW5ndGggLSB0aGUgbWluaW11bSBsZW5ndGggb2YgdGhlIG91dHB1dCBoZXggc3RyaW5nIChpbiBieXRlcylcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBoZXgtZW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZGF0YSwgYXMgYSBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gYzMyZGVjb2RlKGMzMmlucHV0LCBtaW5MZW5ndGgpIHtcbiAgICBjMzJpbnB1dCA9IGMzMm5vcm1hbGl6ZShjMzJpbnB1dCk7XG4gICAgLy8gbXVzdCByZXN1bHQgaW4gYSBjMzIgc3RyaW5nXG4gICAgaWYgKCFjMzJpbnB1dC5tYXRjaChgXlske2V4cG9ydHMuYzMyfV0qJGApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGEgYzMyLWVuY29kZWQgc3RyaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IHplcm9QcmVmaXggPSBjMzJpbnB1dC5tYXRjaChgXiR7ZXhwb3J0cy5jMzJbMF19KmApO1xuICAgIGNvbnN0IG51bUxlYWRpbmdaZXJvQnl0ZXMgPSB6ZXJvUHJlZml4ID8gemVyb1ByZWZpeFswXS5sZW5ndGggOiAwO1xuICAgIGxldCByZXMgPSBbXTtcbiAgICBsZXQgY2FycnkgPSAwO1xuICAgIGxldCBjYXJyeUJpdHMgPSAwO1xuICAgIGZvciAobGV0IGkgPSBjMzJpbnB1dC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAoY2FycnlCaXRzID09PSA0KSB7XG4gICAgICAgICAgICByZXMudW5zaGlmdChoZXhbY2FycnldKTtcbiAgICAgICAgICAgIGNhcnJ5Qml0cyA9IDA7XG4gICAgICAgICAgICBjYXJyeSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudENvZGUgPSBleHBvcnRzLmMzMi5pbmRleE9mKGMzMmlucHV0W2ldKSA8PCBjYXJyeUJpdHM7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IGN1cnJlbnRDb2RlICsgY2Fycnk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRIZXhEaWdpdCA9IGhleFtjdXJyZW50VmFsdWUgJSAxNl07XG4gICAgICAgIGNhcnJ5Qml0cyArPSAxO1xuICAgICAgICBjYXJyeSA9IGN1cnJlbnRWYWx1ZSA+PiA0O1xuICAgICAgICBpZiAoY2FycnkgPiAxIDw8IGNhcnJ5Qml0cykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYW5pYyBlcnJvciBpbiBkZWNvZGluZy4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXMudW5zaGlmdChjdXJyZW50SGV4RGlnaXQpO1xuICAgIH1cbiAgICAvLyBvbmUgbGFzdCBjYXJyeVxuICAgIHJlcy51bnNoaWZ0KGhleFtjYXJyeV0pO1xuICAgIGlmIChyZXMubGVuZ3RoICUgMiA9PT0gMSkge1xuICAgICAgICByZXMudW5zaGlmdCgnMCcpO1xuICAgIH1cbiAgICBsZXQgaGV4TGVhZGluZ1plcm9zID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocmVzW2ldICE9PSAnMCcpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGV4TGVhZGluZ1plcm9zKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzID0gcmVzLnNsaWNlKGhleExlYWRpbmdaZXJvcyAtIChoZXhMZWFkaW5nWmVyb3MgJSAyKSk7XG4gICAgbGV0IGhleFN0ciA9IHJlcy5qb2luKCcnKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUxlYWRpbmdaZXJvQnl0ZXM7IGkrKykge1xuICAgICAgICBoZXhTdHIgPSBgMDAke2hleFN0cn1gO1xuICAgIH1cbiAgICBpZiAobWluTGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gbWluTGVuZ3RoICogMiAtIGhleFN0ci5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkgKz0gMikge1xuICAgICAgICAgICAgaGV4U3RyID0gYDAwJHtoZXhTdHJ9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGV4U3RyO1xufVxuZXhwb3J0cy5jMzJkZWNvZGUgPSBjMzJkZWNvZGU7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJjMzJkZWNvZGUiLCJjMzJub3JtYWxpemUiLCJjMzJlbmNvZGUiLCJjMzIiLCJ1dGlsc18xIiwicmVxdWlyZSIsImhleCIsImlucHV0SGV4IiwibWluTGVuZ3RoIiwibWF0Y2giLCJFcnJvciIsImxlbmd0aCIsInRvTG93ZXJDYXNlIiwicmVzIiwiY2FycnkiLCJpIiwiY3VycmVudENvZGUiLCJpbmRleE9mIiwibmV4dENvZGUiLCJuZXh0Qml0cyIsIm5leHRMb3dCaXRzIiwiY3VyQzMyRGlnaXQiLCJ1bnNoaWZ0IiwiQzMybGVhZGluZ1plcm9zIiwic2xpY2UiLCJ6ZXJvUHJlZml4IiwiVGV4dERlY29kZXIiLCJkZWNvZGUiLCJoZXhUb0J5dGVzIiwibnVtTGVhZGluZ1plcm9CeXRlc0luSGV4IiwiY291bnQiLCJqb2luIiwiYzMyaW5wdXQiLCJ0b1VwcGVyQ2FzZSIsInJlcGxhY2UiLCJudW1MZWFkaW5nWmVyb0J5dGVzIiwiY2FycnlCaXRzIiwiY3VycmVudFZhbHVlIiwiY3VycmVudEhleERpZ2l0IiwiaGV4TGVhZGluZ1plcm9zIiwiaGV4U3RyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/c32check/lib/encoding.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/c32check/lib/index.js":
/*!********************************************!*\
  !*** ./node_modules/c32check/lib/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.b58ToC32 = exports.c32ToB58 = exports.versions = exports.c32normalize = exports.c32addressDecode = exports.c32address = exports.c32checkDecode = exports.c32checkEncode = exports.c32decode = exports.c32encode = void 0;\nconst encoding_1 = __webpack_require__(/*! ./encoding */ \"(ssr)/./node_modules/c32check/lib/encoding.js\");\nObject.defineProperty(exports, \"c32encode\", ({\n    enumerable: true,\n    get: function() {\n        return encoding_1.c32encode;\n    }\n}));\nObject.defineProperty(exports, \"c32decode\", ({\n    enumerable: true,\n    get: function() {\n        return encoding_1.c32decode;\n    }\n}));\nObject.defineProperty(exports, \"c32normalize\", ({\n    enumerable: true,\n    get: function() {\n        return encoding_1.c32normalize;\n    }\n}));\nconst checksum_1 = __webpack_require__(/*! ./checksum */ \"(ssr)/./node_modules/c32check/lib/checksum.js\");\nObject.defineProperty(exports, \"c32checkEncode\", ({\n    enumerable: true,\n    get: function() {\n        return checksum_1.c32checkEncode;\n    }\n}));\nObject.defineProperty(exports, \"c32checkDecode\", ({\n    enumerable: true,\n    get: function() {\n        return checksum_1.c32checkDecode;\n    }\n}));\nconst address_1 = __webpack_require__(/*! ./address */ \"(ssr)/./node_modules/c32check/lib/address.js\");\nObject.defineProperty(exports, \"c32address\", ({\n    enumerable: true,\n    get: function() {\n        return address_1.c32address;\n    }\n}));\nObject.defineProperty(exports, \"c32addressDecode\", ({\n    enumerable: true,\n    get: function() {\n        return address_1.c32addressDecode;\n    }\n}));\nObject.defineProperty(exports, \"c32ToB58\", ({\n    enumerable: true,\n    get: function() {\n        return address_1.c32ToB58;\n    }\n}));\nObject.defineProperty(exports, \"b58ToC32\", ({\n    enumerable: true,\n    get: function() {\n        return address_1.b58ToC32;\n    }\n}));\nObject.defineProperty(exports, \"versions\", ({\n    enumerable: true,\n    get: function() {\n        return address_1.versions;\n    }\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYzMyY2hlY2svbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxnQkFBZ0IsR0FBR0EsZ0JBQWdCLEdBQUdBLGdCQUFnQixHQUFHQSxvQkFBb0IsR0FBR0Esd0JBQXdCLEdBQUdBLGtCQUFrQixHQUFHQSxzQkFBc0IsR0FBR0Esc0JBQXNCLEdBQUdBLGlCQUFpQixHQUFHQSxpQkFBaUIsR0FBRyxLQUFLO0FBQy9OLE1BQU1ZLGFBQWFDLG1CQUFPQSxDQUFDLGlFQUFZO0FBQ3ZDZiw2Q0FBNEM7SUFBRWdCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9ILFdBQVdELFNBQVM7SUFBRTtBQUFFLENBQUMsRUFBQztBQUNwSGIsNkNBQTRDO0lBQUVnQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPSCxXQUFXRixTQUFTO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDcEhaLGdEQUErQztJQUFFZ0IsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0gsV0FBV1AsWUFBWTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQzFILE1BQU1XLGFBQWFILG1CQUFPQSxDQUFDLGlFQUFZO0FBQ3ZDZixrREFBaUQ7SUFBRWdCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9DLFdBQVdQLGNBQWM7SUFBRTtBQUFFLENBQUMsRUFBQztBQUM5SFgsa0RBQWlEO0lBQUVnQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPQyxXQUFXUixjQUFjO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDOUgsTUFBTVMsWUFBWUosbUJBQU9BLENBQUMsK0RBQVc7QUFDckNmLDhDQUE2QztJQUFFZ0IsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0UsVUFBVVYsVUFBVTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3JIVCxvREFBbUQ7SUFBRWdCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9FLFVBQVVYLGdCQUFnQjtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ2pJUiw0Q0FBMkM7SUFBRWdCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9FLFVBQVVkLFFBQVE7SUFBRTtBQUFFLENBQUMsRUFBQztBQUNqSEwsNENBQTJDO0lBQUVnQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRSxVQUFVZixRQUFRO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDakhKLDRDQUEyQztJQUFFZ0IsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0UsVUFBVWIsUUFBUTtJQUFFO0FBQUUsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmVyaWZpZWQtZGV4LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2MzMmNoZWNrL2xpYi9pbmRleC5qcz9lMjc3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5iNThUb0MzMiA9IGV4cG9ydHMuYzMyVG9CNTggPSBleHBvcnRzLnZlcnNpb25zID0gZXhwb3J0cy5jMzJub3JtYWxpemUgPSBleHBvcnRzLmMzMmFkZHJlc3NEZWNvZGUgPSBleHBvcnRzLmMzMmFkZHJlc3MgPSBleHBvcnRzLmMzMmNoZWNrRGVjb2RlID0gZXhwb3J0cy5jMzJjaGVja0VuY29kZSA9IGV4cG9ydHMuYzMyZGVjb2RlID0gZXhwb3J0cy5jMzJlbmNvZGUgPSB2b2lkIDA7XG5jb25zdCBlbmNvZGluZ18xID0gcmVxdWlyZShcIi4vZW5jb2RpbmdcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjMzJlbmNvZGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuY29kaW5nXzEuYzMyZW5jb2RlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYzMyZGVjb2RlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlbmNvZGluZ18xLmMzMmRlY29kZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImMzMm5vcm1hbGl6ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZW5jb2RpbmdfMS5jMzJub3JtYWxpemU7IH0gfSk7XG5jb25zdCBjaGVja3N1bV8xID0gcmVxdWlyZShcIi4vY2hlY2tzdW1cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjMzJjaGVja0VuY29kZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2hlY2tzdW1fMS5jMzJjaGVja0VuY29kZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImMzMmNoZWNrRGVjb2RlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjaGVja3N1bV8xLmMzMmNoZWNrRGVjb2RlOyB9IH0pO1xuY29uc3QgYWRkcmVzc18xID0gcmVxdWlyZShcIi4vYWRkcmVzc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImMzMmFkZHJlc3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFkZHJlc3NfMS5jMzJhZGRyZXNzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYzMyYWRkcmVzc0RlY29kZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWRkcmVzc18xLmMzMmFkZHJlc3NEZWNvZGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjMzJUb0I1OFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWRkcmVzc18xLmMzMlRvQjU4OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYjU4VG9DMzJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFkZHJlc3NfMS5iNThUb0MzMjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInZlcnNpb25zXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhZGRyZXNzXzEudmVyc2lvbnM7IH0gfSk7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJiNThUb0MzMiIsImMzMlRvQjU4IiwidmVyc2lvbnMiLCJjMzJub3JtYWxpemUiLCJjMzJhZGRyZXNzRGVjb2RlIiwiYzMyYWRkcmVzcyIsImMzMmNoZWNrRGVjb2RlIiwiYzMyY2hlY2tFbmNvZGUiLCJjMzJkZWNvZGUiLCJjMzJlbmNvZGUiLCJlbmNvZGluZ18xIiwicmVxdWlyZSIsImVudW1lcmFibGUiLCJnZXQiLCJjaGVja3N1bV8xIiwiYWRkcmVzc18xIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/c32check/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/c32check/node_modules/base-x/src/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/c32check/node_modules/base-x/src/index.js ***!
  \****************************************************************/
/***/ ((module) => {

eval("\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base(ALPHABET) {\n    if (ALPHABET.length >= 255) {\n        throw new TypeError(\"Alphabet too long\");\n    }\n    var BASE_MAP = new Uint8Array(256);\n    for(var j = 0; j < BASE_MAP.length; j++){\n        BASE_MAP[j] = 255;\n    }\n    for(var i = 0; i < ALPHABET.length; i++){\n        var x = ALPHABET.charAt(i);\n        var xc = x.charCodeAt(0);\n        if (BASE_MAP[xc] !== 255) {\n            throw new TypeError(x + \" is ambiguous\");\n        }\n        BASE_MAP[xc] = i;\n    }\n    var BASE = ALPHABET.length;\n    var LEADER = ALPHABET.charAt(0);\n    var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n    ;\n    var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n    ;\n    function encode(source) {\n        if (source instanceof Uint8Array) {} else if (ArrayBuffer.isView(source)) {\n            source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n        } else if (Array.isArray(source)) {\n            source = Uint8Array.from(source);\n        }\n        if (!(source instanceof Uint8Array)) {\n            throw new TypeError(\"Expected Uint8Array\");\n        }\n        if (source.length === 0) {\n            return \"\";\n        }\n        // Skip & count leading zeroes.\n        var zeroes = 0;\n        var length = 0;\n        var pbegin = 0;\n        var pend = source.length;\n        while(pbegin !== pend && source[pbegin] === 0){\n            pbegin++;\n            zeroes++;\n        }\n        // Allocate enough space in big-endian base58 representation.\n        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;\n        var b58 = new Uint8Array(size);\n        // Process the bytes.\n        while(pbegin !== pend){\n            var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n            var i = 0;\n            for(var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++){\n                carry += 256 * b58[it1] >>> 0;\n                b58[it1] = carry % BASE >>> 0;\n                carry = carry / BASE >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error(\"Non-zero carry\");\n            }\n            length = i;\n            pbegin++;\n        }\n        // Skip leading zeroes in base58 result.\n        var it2 = size - length;\n        while(it2 !== size && b58[it2] === 0){\n            it2++;\n        }\n        // Translate the result into a string.\n        var str = LEADER.repeat(zeroes);\n        for(; it2 < size; ++it2){\n            str += ALPHABET.charAt(b58[it2]);\n        }\n        return str;\n    }\n    function decodeUnsafe(source) {\n        if (typeof source !== \"string\") {\n            throw new TypeError(\"Expected String\");\n        }\n        if (source.length === 0) {\n            return new Uint8Array();\n        }\n        var psz = 0;\n        // Skip and count leading '1's.\n        var zeroes = 0;\n        var length = 0;\n        while(source[psz] === LEADER){\n            zeroes++;\n            psz++;\n        }\n        // Allocate enough space in big-endian base256 representation.\n        var size = (source.length - psz) * FACTOR + 1 >>> 0 // log(58) / log(256), rounded up.\n        ;\n        var b256 = new Uint8Array(size);\n        // Process the characters.\n        while(source[psz]){\n            // Find code of next character\n            var charCode = source.charCodeAt(psz);\n            // Base map can not be indexed using char code\n            if (charCode > 255) {\n                return;\n            }\n            // Decode character\n            var carry = BASE_MAP[charCode];\n            // Invalid character\n            if (carry === 255) {\n                return;\n            }\n            var i = 0;\n            for(var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++){\n                carry += BASE * b256[it3] >>> 0;\n                b256[it3] = carry % 256 >>> 0;\n                carry = carry / 256 >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error(\"Non-zero carry\");\n            }\n            length = i;\n            psz++;\n        }\n        // Skip leading zeroes in b256.\n        var it4 = size - length;\n        while(it4 !== size && b256[it4] === 0){\n            it4++;\n        }\n        var vch = new Uint8Array(zeroes + (size - it4));\n        var j = zeroes;\n        while(it4 !== size){\n            vch[j++] = b256[it4++];\n        }\n        return vch;\n    }\n    function decode(string) {\n        var buffer = decodeUnsafe(string);\n        if (buffer) {\n            return buffer;\n        }\n        throw new Error(\"Non-base\" + BASE + \" character\");\n    }\n    return {\n        encode: encode,\n        decodeUnsafe: decodeUnsafe,\n        decode: decode\n    };\n}\nmodule.exports = base;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYzMyY2hlY2svbm9kZV9tb2R1bGVzL2Jhc2UteC9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSw2QkFBNkI7QUFDN0IseUNBQXlDO0FBQ3pDLG1FQUFtRTtBQUNuRSxtRUFBbUU7QUFDbkUsc0VBQXNFO0FBQ3RFLFNBQVNBLEtBQU1DLFFBQVE7SUFDckIsSUFBSUEsU0FBU0MsTUFBTSxJQUFJLEtBQUs7UUFBRSxNQUFNLElBQUlDLFVBQVU7SUFBcUI7SUFDdkUsSUFBSUMsV0FBVyxJQUFJQyxXQUFXO0lBQzlCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRixTQUFTRixNQUFNLEVBQUVJLElBQUs7UUFDeENGLFFBQVEsQ0FBQ0UsRUFBRSxHQUFHO0lBQ2hCO0lBQ0EsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlOLFNBQVNDLE1BQU0sRUFBRUssSUFBSztRQUN4QyxJQUFJQyxJQUFJUCxTQUFTUSxNQUFNLENBQUNGO1FBQ3hCLElBQUlHLEtBQUtGLEVBQUVHLFVBQVUsQ0FBQztRQUN0QixJQUFJUCxRQUFRLENBQUNNLEdBQUcsS0FBSyxLQUFLO1lBQUUsTUFBTSxJQUFJUCxVQUFVSyxJQUFJO1FBQWlCO1FBQ3JFSixRQUFRLENBQUNNLEdBQUcsR0FBR0g7SUFDakI7SUFDQSxJQUFJSyxPQUFPWCxTQUFTQyxNQUFNO0lBQzFCLElBQUlXLFNBQVNaLFNBQVNRLE1BQU0sQ0FBQztJQUM3QixJQUFJSyxTQUFTQyxLQUFLQyxHQUFHLENBQUNKLFFBQVFHLEtBQUtDLEdBQUcsQ0FBQyxLQUFLLG1DQUFtQzs7SUFDL0UsSUFBSUMsVUFBVUYsS0FBS0MsR0FBRyxDQUFDLE9BQU9ELEtBQUtDLEdBQUcsQ0FBQ0osTUFBTSxtQ0FBbUM7O0lBQ2hGLFNBQVNNLE9BQVFDLE1BQU07UUFDckIsSUFBSUEsa0JBQWtCZCxZQUFZLENBQ2xDLE9BQU8sSUFBSWUsWUFBWUMsTUFBTSxDQUFDRixTQUFTO1lBQ3JDQSxTQUFTLElB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T0FBTyxHQUFHLENBQUNFLFVBQVUsS0FBSzFCLElBQUlMLE1BQUssS0FBT3lDLFFBQVEsQ0FBQyxHQUFJQSxPQUFPcEMsSUFBSztnQkFDaEYwQixTQUFTLE9BQVFRLElBQUksQ0FBQ0UsSUFBSSxLQUFNO2dCQUNoQ0YsSUFBSSxDQUFDRSxJQUFJLEdBQUcsUUFBUyxRQUFTO2dCQUM5QlYsUUFBUSxRQUFTLFFBQVM7WUFDNUI7WUFDQSxJQUFJQSxVQUFVLEdBQUc7Z0JBQUUsTUFBTSxJQUFJRSxNQUFNO1lBQWtCO1lBQ3JEakMsU0FBU0s7WUFDVGlDO1FBQ0Y7UUFDSSwrQkFBK0I7UUFDbkMsSUFBSUksTUFBTWIsT0FBTzdCO1FBQ2pCLE1BQU8wQyxRQUFRYixRQUFRVSxJQUFJLENBQUNHLElBQUksS0FBSyxFQUFHO1lBQ3RDQTtRQUNGO1FBQ0EsSUFBSUMsTUFBTSxJQUFJeEMsV0FBV3VCLFNBQVVHLENBQUFBLE9BQU9hLEdBQUU7UUFDNUMsSUFBSXRDLElBQUlzQjtRQUNSLE1BQU9nQixRQUFRYixLQUFNO1lBQ25CYyxHQUFHLENBQUN2QyxJQUFJLEdBQUdtQyxJQUFJLENBQUNHLE1BQU07UUFDeEI7UUFDQSxPQUFPQztJQUNUO0lBQ0EsU0FBU0MsT0FBUUMsTUFBTTtRQUNyQixJQUFJekIsU0FBU2lCLGFBQWFRO1FBQzFCLElBQUl6QixRQUFRO1lBQUUsT0FBT0E7UUFBTztRQUM1QixNQUFNLElBQUlhLE1BQU0sYUFBYXZCLE9BQU87SUFDdEM7SUFDQSxPQUFPO1FBQ0xNLFFBQVFBO1FBQ1JxQixjQUFjQTtRQUNkTyxRQUFRQTtJQUNWO0FBQ0Y7QUFDQUUsT0FBT0MsT0FBTyxHQUFHakQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92ZXJpZmllZC1kZXgtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvYzMyY2hlY2svbm9kZV9tb2R1bGVzL2Jhc2UteC9zcmMvaW5kZXguanM/MDdhOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbi8vIGJhc2UteCBlbmNvZGluZyAvIGRlY29kaW5nXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTggYmFzZS14IGNvbnRyaWJ1dG9yc1xuLy8gQ29weXJpZ2h0IChjKSAyMDE0LTIwMTggVGhlIEJpdGNvaW4gQ29yZSBkZXZlbG9wZXJzIChiYXNlNTguY3BwKVxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBzb2Z0d2FyZSBsaWNlbnNlLCBzZWUgdGhlIGFjY29tcGFueWluZ1xuLy8gZmlsZSBMSUNFTlNFIG9yIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwLlxuZnVuY3Rpb24gYmFzZSAoQUxQSEFCRVQpIHtcbiAgaWYgKEFMUEhBQkVULmxlbmd0aCA+PSAyNTUpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQWxwaGFiZXQgdG9vIGxvbmcnKSB9XG4gIHZhciBCQVNFX01BUCA9IG5ldyBVaW50OEFycmF5KDI1NilcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBCQVNFX01BUC5sZW5ndGg7IGorKykge1xuICAgIEJBU0VfTUFQW2pdID0gMjU1XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBBTFBIQUJFVC5sZW5ndGg7IGkrKykge1xuICAgIHZhciB4ID0gQUxQSEFCRVQuY2hhckF0KGkpXG4gICAgdmFyIHhjID0geC5jaGFyQ29kZUF0KDApXG4gICAgaWYgKEJBU0VfTUFQW3hjXSAhPT0gMjU1KSB7IHRocm93IG5ldyBUeXBlRXJyb3IoeCArICcgaXMgYW1iaWd1b3VzJykgfVxuICAgIEJBU0VfTUFQW3hjXSA9IGlcbiAgfVxuICB2YXIgQkFTRSA9IEFMUEhBQkVULmxlbmd0aFxuICB2YXIgTEVBREVSID0gQUxQSEFCRVQuY2hhckF0KDApXG4gIHZhciBGQUNUT1IgPSBNYXRoLmxvZyhCQVNFKSAvIE1hdGgubG9nKDI1NikgLy8gbG9nKEJBU0UpIC8gbG9nKDI1NiksIHJvdW5kZWQgdXBcbiAgdmFyIGlGQUNUT1IgPSBNYXRoLmxvZygyNTYpIC8gTWF0aC5sb2coQkFTRSkgLy8gbG9nKDI1NikgLyBsb2coQkFTRSksIHJvdW5kZWQgdXBcbiAgZnVuY3Rpb24gZW5jb2RlIChzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHNvdXJjZSkpIHtcbiAgICAgIHNvdXJjZSA9IG5ldyBVaW50OEFycmF5KHNvdXJjZS5idWZmZXIsIHNvdXJjZS5ieXRlT2Zmc2V0LCBzb3VyY2UuYnl0ZUxlbmd0aClcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgc291cmNlID0gVWludDhBcnJheS5mcm9tKHNvdXJjZSlcbiAgICB9XG4gICAgaWYgKCEoc291cmNlIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgVWludDhBcnJheScpIH1cbiAgICBpZiAoc291cmNlLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gJycgfVxuICAgICAgICAvLyBTa2lwICYgY291bnQgbGVhZGluZyB6ZXJvZXMuXG4gICAgdmFyIHplcm9lcyA9IDBcbiAgICB2YXIgbGVuZ3RoID0gMFxuICAgIHZhciBwYmVnaW4gPSAwXG4gICAgdmFyIHBlbmQgPSBzb3VyY2UubGVuZ3RoXG4gICAgd2hpbGUgKHBiZWdpbiAhPT0gcGVuZCAmJiBzb3VyY2VbcGJlZ2luXSA9PT0gMCkge1xuICAgICAgcGJlZ2luKytcbiAgICAgIHplcm9lcysrXG4gICAgfVxuICAgICAgICAvLyBBbGxvY2F0ZSBlbm91Z2ggc3BhY2UgaW4gYmlnLWVuZGlhbiBiYXNlNTggcmVwcmVzZW50YXRpb24uXG4gICAgdmFyIHNpemUgPSAoKHBlbmQgLSBwYmVnaW4pICogaUZBQ1RPUiArIDEpID4+PiAwXG4gICAgdmFyIGI1OCA9IG5ldyBVaW50OEFycmF5KHNpemUpXG4gICAgICAgIC8vIFByb2Nlc3MgdGhlIGJ5dGVzLlxuICAgIHdoaWxlIChwYmVnaW4gIT09IHBlbmQpIHtcbiAgICAgIHZhciBjYXJyeSA9IHNvdXJjZVtwYmVnaW5dXG4gICAgICAgICAgICAvLyBBcHBseSBcImI1OCA9IGI1OCAqIDI1NiArIGNoXCIuXG4gICAgICB2YXIgaSA9IDBcbiAgICAgIGZvciAodmFyIGl0MSA9IHNpemUgLSAxOyAoY2FycnkgIT09IDAgfHwgaSA8IGxlbmd0aCkgJiYgKGl0MSAhPT0gLTEpOyBpdDEtLSwgaSsrKSB7XG4gICAgICAgIGNhcnJ5ICs9ICgyNTYgKiBiNThbaXQxXSkgPj4+IDBcbiAgICAgICAgYjU4W2l0MV0gPSAoY2FycnkgJSBCQVNFKSA+Pj4gMFxuICAgICAgICBjYXJyeSA9IChjYXJyeSAvIEJBU0UpID4+PiAwXG4gICAgICB9XG4gICAgICBpZiAoY2FycnkgIT09IDApIHsgdGhyb3cgbmV3IEVycm9yKCdOb24temVybyBjYXJyeScpIH1cbiAgICAgIGxlbmd0aCA9IGlcbiAgICAgIHBiZWdpbisrXG4gICAgfVxuICAgICAgICAvLyBTa2lwIGxlYWRpbmcgemVyb2VzIGluIGJhc2U1OCByZXN1bHQuXG4gICAgdmFyIGl0MiA9IHNpemUgLSBsZW5ndGhcbiAgICB3aGlsZSAoaXQyICE9PSBzaXplICYmIGI1OFtpdDJdID09PSAwKSB7XG4gICAgICBpdDIrK1xuICAgIH1cbiAgICAgICAgLy8gVHJhbnNsYXRlIHRoZSByZXN1bHQgaW50byBhIHN0cmluZy5cbiAgICB2YXIgc3RyID0gTEVBREVSLnJlcGVhdCh6ZXJvZXMpXG4gICAgZm9yICg7IGl0MiA8IHNpemU7ICsraXQyKSB7IHN0ciArPSBBTFBIQUJFVC5jaGFyQXQoYjU4W2l0Ml0pIH1cbiAgICByZXR1cm4gc3RyXG4gIH1cbiAgZnVuY3Rpb24gZGVjb2RlVW5zYWZlIChzb3VyY2UpIHtcbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ3N0cmluZycpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgU3RyaW5nJykgfVxuICAgIGlmIChzb3VyY2UubGVuZ3RoID09PSAwKSB7IHJldHVybiBuZXcgVWludDhBcnJheSgpIH1cbiAgICB2YXIgcHN6ID0gMFxuICAgICAgICAvLyBTa2lwIGFuZCBjb3VudCBsZWFkaW5nICcxJ3MuXG4gICAgdmFyIHplcm9lcyA9IDBcbiAgICB2YXIgbGVuZ3RoID0gMFxuICAgIHdoaWxlIChzb3VyY2VbcHN6XSA9PT0gTEVBREVSKSB7XG4gICAgICB6ZXJvZXMrK1xuICAgICAgcHN6KytcbiAgICB9XG4gICAgICAgIC8vIEFsbG9jYXRlIGVub3VnaCBzcGFjZSBpbiBiaWctZW5kaWFuIGJhc2UyNTYgcmVwcmVzZW50YXRpb24uXG4gICAgdmFyIHNpemUgPSAoKChzb3VyY2UubGVuZ3RoIC0gcHN6KSAqIEZBQ1RPUikgKyAxKSA+Pj4gMCAvLyBsb2coNTgpIC8gbG9nKDI1NiksIHJvdW5kZWQgdXAuXG4gICAgdmFyIGIyNTYgPSBuZXcgVWludDhBcnJheShzaXplKVxuICAgICAgICAvLyBQcm9jZXNzIHRoZSBjaGFyYWN0ZXJzLlxuICAgIHdoaWxlIChzb3VyY2VbcHN6XSkge1xuICAgICAgICAgICAgLy8gRmluZCBjb2RlIG9mIG5leHQgY2hhcmFjdGVyXG4gICAgICB2YXIgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChwc3opXG4gICAgICAgICAgICAvLyBCYXNlIG1hcCBjYW4gbm90IGJlIGluZGV4ZWQgdXNpbmcgY2hhciBjb2RlXG4gICAgICBpZiAoY2hhckNvZGUgPiAyNTUpIHsgcmV0dXJuIH1cbiAgICAgICAgICAgIC8vIERlY29kZSBjaGFyYWN0ZXJcbiAgICAgIHZhciBjYXJyeSA9IEJBU0VfTUFQW2NoYXJDb2RlXVxuICAgICAgICAgICAgLy8gSW52YWxpZCBjaGFyYWN0ZXJcbiAgICAgIGlmIChjYXJyeSA9PT0gMjU1KSB7IHJldHVybiB9XG4gICAgICB2YXIgaSA9IDBcbiAgICAgIGZvciAodmFyIGl0MyA9IHNpemUgLSAxOyAoY2FycnkgIT09IDAgfHwgaSA8IGxlbmd0aCkgJiYgKGl0MyAhPT0gLTEpOyBpdDMtLSwgaSsrKSB7XG4gICAgICAgIGNhcnJ5ICs9IChCQVNFICogYjI1NltpdDNdKSA+Pj4gMFxuICAgICAgICBiMjU2W2l0M10gPSAoY2FycnkgJSAyNTYpID4+PiAwXG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gMjU2KSA+Pj4gMFxuICAgICAgfVxuICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7IHRocm93IG5ldyBFcnJvcignTm9uLXplcm8gY2FycnknKSB9XG4gICAgICBsZW5ndGggPSBpXG4gICAgICBwc3orK1xuICAgIH1cbiAgICAgICAgLy8gU2tpcCBsZWFkaW5nIHplcm9lcyBpbiBiMjU2LlxuICAgIHZhciBpdDQgPSBzaXplIC0gbGVuZ3RoXG4gICAgd2hpbGUgKGl0NCAhPT0gc2l6ZSAmJiBiMjU2W2l0NF0gPT09IDApIHtcbiAgICAgIGl0NCsrXG4gICAgfVxuICAgIHZhciB2Y2ggPSBuZXcgVWludDhBcnJheSh6ZXJvZXMgKyAoc2l6ZSAtIGl0NCkpXG4gICAgdmFyIGogPSB6ZXJvZXNcbiAgICB3aGlsZSAoaXQ0ICE9PSBzaXplKSB7XG4gICAgICB2Y2hbaisrXSA9IGIyNTZbaXQ0KytdXG4gICAgfVxuICAgIHJldHVybiB2Y2hcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGUgKHN0cmluZykge1xuICAgIHZhciBidWZmZXIgPSBkZWNvZGVVbnNhZmUoc3RyaW5nKVxuICAgIGlmIChidWZmZXIpIHsgcmV0dXJuIGJ1ZmZlciB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb24tYmFzZScgKyBCQVNFICsgJyBjaGFyYWN0ZXInKVxuICB9XG4gIHJldHVybiB7XG4gICAgZW5jb2RlOiBlbmNvZGUsXG4gICAgZGVjb2RlVW5zYWZlOiBkZWNvZGVVbnNhZmUsXG4gICAgZGVjb2RlOiBkZWNvZGVcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBiYXNlXG4iXSwibmFtZXMiOlsiYmFzZSIsIkFMUEhBQkVUIiwibGVuZ3RoIiwiVHlwZUVycm9yIiwiQkFTRV9NQVAiLCJVaW50OEFycmF5IiwiaiIsImkiLCJ4IiwiY2hhckF0IiwieGMiLCJjaGFyQ29kZUF0IiwiQkFTRSIsIkxFQURFUiIsIkZBQ1RPUiIsIk1hdGgiLCJsb2ciLCJpRkFDVE9SIiwiZW5jb2RlIiwic291cmNlIiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJidWZmZXIiLCJieXRlT2Zmc2V0IiwiYnl0ZUxlbmd0aCIsIkFycmF5IiwiaXNBcnJheSIsImZyb20iLCJ6ZXJvZXMiLCJwYmVnaW4iLCJwZW5kIiwic2l6ZSIsImI1OCIsImNhcnJ5IiwiaXQxIiwiRXJyb3IiLCJpdDIiLCJzdHIiLCJyZXBlYXQiLCJkZWNvZGVVbnNhZmUiLCJwc3oiLCJiMjU2IiwiY2hhckNvZGUiLCJpdDMiLCJpdDQiLCJ2Y2giLCJkZWNvZGUiLCJzdHJpbmciLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/c32check/node_modules/base-x/src/index.js\n");

/***/ })

};
;